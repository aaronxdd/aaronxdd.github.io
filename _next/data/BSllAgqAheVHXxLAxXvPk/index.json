{"pageProps":{"posts":[{"slug":"method","frontmatter":{"title":"js常用方法集合（一）","date":"June 30, 2021","description":null},"excerpt":"","content":"\n## Array\n\n1. 将输入值转化为数组\n\n``` javascript\nconst castArray = value => Array.isArray(value) ? value : [value];\n\n// Examples\ncastArray(1);               // [1]\ncastArray([1, 2, 3]);       // [1, 2, 3]\n```\n\n2. 判断数组是否为空\n\n``` javascript\nconst isEmpty = arr => Array.isArray(arr) && arr.length === 0;\n\n// Examples\nisEmpty(1);             // false\nisEmpty([]);            // true\nisEmpty([1, 2, 3]);     // false\n```\n\n3. 拷贝一个数组\n\n``` javascript\n// `arr` is an array\nconst clone = arr => arr.slice(0);\n\n// Or\nconst clone = arr => arr.concat([]);\n\n// Or\nconst clone = arr => [...arr];\n\n// Or\nconst clone = arr => Array.from(arr);\n\n// Or\nconst clone = arr => arr.map(v => v);\n```\n\n4. 对比两个数组是否一样\n   \n``` javascript\nconst isEqual = (arr1, arr2) => arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i]);\n\n// Examples\nisEqual([1, 2, 3], [1, 2, 3]);      // true\nisEqual([1, 2, 3], [1, '2', 3]);    // false\n```\n\n5. 根据某个属性将数组转化为对象（属性作为key）\n\n``` javascript\nconst toObject = (arr, key) => arr.reduce((a, b) => ({...a, [b[key]]: b}), {});\n\n// Example\ntoObject(\n    [\n        { id: '1', name: 'Alpha', gender: 'Male' },\n        { id: '2', name: 'Bravo', gender: 'Male' },\n        { id: '3', name: 'Charlie', gender: 'Female' },\n    ],\n    'id'\n);\n/* \n{\n    '1': { id: '1', name: 'Alpha', gender: 'Male' },\n    '2': { id: '2', name: 'Bravo', gender: 'Male' },\n    '3': { id: '3', name: 'Charlie', gender: 'Female' },\n}\n*/\n```\n\n6. 找出数组中最大的值（Number）\n\n``` javascript\nconst indexOfMax = arr => arr.reduce((prev, v, i, a) => v > a[prev] ? i : prev, 0);\n\n// Examples\nindexOfMax([1, 3, 9, 7, 5]);        // 2\nindexOfMax([1, 3, 7, 7, 5]);        // 2\n```\n\n7. 根据属性找出数组中属性值最大的\n\n``` javascript\nconst maxBy = (arr, key) => arr.reduce((a, b) => a[key] >= b[key] ? a : b, {});\n\n// Example\nconst people = [\n    { name: 'Bar', age: 24 },\n    { name: 'Baz', age: 32 },\n    { name: 'Foo', age: 42 },\n    { name: 'Fuzz', age: 36 },\n];\nmaxBy(people, 'age');   // { name: 'Foo', age: 42 }\n```\n\n8. 数组去重\n\n``` javascript\nconst unique = arr => Array.from(new Set(arr));\n\n// Or\nconst unique = arr => arr.filter((el, i, array) => array.indexOf(el) === i);\n```\n\n9. 以属性值为key将数组转化成对象\n\n``` javascript\nconst groupBy = (arr, key) => arr.reduce((acc, item) => ((acc[item[key]] = [...(acc[item[key]] || []), item]), acc), {});\n\n// Example\ngroupBy([\n    { branch: 'audi', model: 'q8', year: '2019' },\n    { branch: 'audi', model: 'rs7', year: '2020' },\n    { branch: 'ford', model: 'mustang', year: '2019' },\n    { branch: 'ford', model: 'explorer', year: '2020' },\n    { branch: 'bmw', model: 'x7', year: '2020' },\n], 'branch');\n\n/*\n{\n    audi: [\n        { branch: 'audi', model: 'q8', year: '2019' },\n        { branch: 'audi', model: 'rs7', year: '2020' }\n    ],\n    bmw: [\n        { branch: 'bmw', model: 'x7', year: '2020' }\n    ],\n    ford: [\n        { branch: 'ford', model: 'mustang', year: '2019' },\n        { branch: 'ford', model: 'explorer', year: '2020' }\n    ],\n}\n*/\n```\n\n10. 根据属性值给数组排序\n\n``` javascript\nconst sortBy = (arr, k) => arr.concat().sort((a, b) => (a[k] > b[k]) ? 1 : ((a[k] < b[k]) ? -1 : 0));\n\n// Example\nconst people = [\n    { name: 'Foo', age: 42 },\n    { name: 'Bar', age: 24 },\n    { name: 'Fuzz', age: 36 },\n    { name: 'Baz', age: 32 },\n];\nsortBy(people, 'age');\n\n// returns\n//  [\n//      { name: 'Bar', age: 24 },\n//      { name: 'Baz', age: 32 },\n//      { name: 'Fuzz', age: 36 },\n//      { name: 'Foo', age: 42 },\n//  ]\n```\n\n## DOM\n\n1. 判断是否为某个元素的子节点\n\n``` javascript\nconst isDescendant = (child, parent) => parent.contains(child);\n```\n\n2. 判断当前元素是否是Focus状态\n\n``` javascript\nconst isFocus = ele => ele === document.activeElement;\n```\n\n3. 判断页面是否滑到底部\n\n``` javascript\nconst isAtBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n```\n\n4. 当前浏览器判断\n\n``` javascript\n\n// IE\nconst isIE = !!document.documentMode;\n\n// Chrome\nconst isChrome = !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);\n\n// macOS browser\nconst isMacBrowser = /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n```\n\n5. 获取用户选中的文本\n\n``` javascript\nconst getSelectedText = () => window.getSelection().toString();\n```\n\n6. 隐藏元素\n  \n``` javascript\nconst hide = ele => ele.style.display = 'none';\n\n// Or\nconst hide = ele => ele.style.visibility = 'hidden';\n\n// Or\nconst hide = ele => ele.hidden = true;\n```\n\n7. 将元素插入某个元素之后\n\n``` javascript\nconst insertAfter = (ele, anotherEle) => anotherEle.parentNode.insertBefore(ele, anotherEle.nextSibling);\n\n// Or\nconst insertAfter = (ele, anotherEle) => anotherEle.insertAdjacentElement('afterend', ele);\n```\n\n8. 跳转页面\n\n``` javascript\nconst goTo = url => location.href = url;\n```\n\n9. 重新加载当前页\n\n``` javascript\nconst reload = () => location.reload();\n\n// Or\nconst reload = () => (location.href = location.href);\n```\n\n10. 替换元素\n\n``` javascript\nconst replace = (ele, newEle) => ele.parentNode.replaceChild(newEle, ele);\n```\n\n11. 回到页面顶部\n\n``` javascript\nconst goToTop = () => window.scrollTo(0, 0);\n```"},{"slug":"applyMiddleware","frontmatter":{"title":"redux源码系列之applyMiddleware","date":"June 28, 2021","description":null},"excerpt":"","content":"\n终于来到 **applyMiddleware** 部分，理解了 [**compose**](https://xudongdong.site/post/compose) 和 [**Currying**](https://xudongdong.site/post/currying)，这部分源码也变得很好理解\n\n这个方法是用来应用中间件的，用过 **node** 的同学应该比较了解，中间件我的理解类似于插件，一般为了避免系统框架过于臃肿，我们把常用的功能剥离开来，以中间件的形式插入到框架中来实现复杂的应用处理\n\n我们首先看下 **applyMiddleware** 的用法\n\n``` js\nimport { applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\nconst store = createStore(reducer, applyMiddleware(thunk, logger))\n```\n\n**createStore** 内部的调用\n\n``` js\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 传入参数的判断\n  // ...\n\n  // 参数中enhancer function存在，一般是指applyMiddleware()\n  if (typeof enhancer !== \"undefined\" && typeof enhancer === \"function\") {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  // 省略\n}\n```\n\n由此可以得出 **applyMiddleware** 的 **API** 调用\n\n``` js\napplyMiddleware(thunk, logger)(createStore)(reducer, preloadedState);\n\n// applyMiddleware(...middlewares)(createStore)(reducer, preloadedState);\n```\n\n结合源码\n\n我们将源码中 **TS** 部分去除，得出函数主体代码\n\n``` javascript\nimport { compose } from \"./compose\";\n\nfunction applyMiddleware(...middlewares) {\n  // use Currying function\n  return (createStore) => (reducer, preloadedState) => {\n    // 获取store\n    const store = createStore(reducer, preloadedState);\n    // 初始化dispatch\n    let dispatch = () => {\n      // 在dispatch完成正在赋值之前，调用会报错\n      throw new Error(\"目前还不能使用dispatch\")\n    }\n\n    // 给每个中间件的默认传参：getState，dispatch\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    \n    // 加入默认参数后的中间件chain\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 对chain做compose操作，并赋值给dispatch\n    dispatch = compose(...chain)(store.dispatch)\n  }\n\n  // 返回store的属性和dispatch\n  return {\n    ...store,\n    dispatch\n  }\n}\n```\n\n主要难以理解的部分还是 **compose** 这一块\n\n我们拿两个中间件做解析\n\n``` javascript\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\napplyMiddleware(thunk, logger)(createStore)(reducer, preloadedState);\n\n// applyMiddleware chain部分\nconst middlewareAPI = { getState, dispatch }\n\nconst chain = [thunk, logger].map(middleware => middleware(middlewareAPI))\n// const chain = [thunk(middlewareAPI), logger(middlewareAPI)]\n// const chain = [thunk({ getState, dispatch }), logger({ getState, dispatch })]\n\n// applyMiddleware compose dispatch部分\ndispatch = compose(...chain)(store.dispatch)\n// dispatch = compose(thunk({ getState, dispatch }), logger({ getState, dispatch }))(store.dispatch)\n\n// 根据 compose 代码可转化为\n// dispatch = thunk({ getState, dispatch })(logger({ getState, dispatch })(store.dispatch))\n```\n\n代码到这边我们需要结合 **redux-thunk** 源码继续解析了\n\n``` js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n\n把\n``` js\ndispatch = thunk({ getState, dispatch })(logger({ getState, dispatch })(store.dispatch))\n```\n\n放到 **thunk** 中\n\n``` js\ndispatch = ({ getState, dispatch }) => {\n  return ({ getState, dispatch }) => (logger({ getState, dispatch })(store.dispatch)) => (action) => {\n\n    // 如果有异步action，会先执行异步action，在执行传进来的logger function\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return logger({ getState, dispatch })(store.dispatch)(action);\n  }\n}\n```\n\n应用了 **thunk** 和 **logger** 的 **redux** 应用，会先执行异步 **action**，在执行 **logger** 中间件。\n\n从代码上看，**applyMiddleware** 最主要的作用就是对原始的 **dispatch** 方法进行了重新赋值，并将它与 **store** 的属性返回。\n\n\n## 参考\n- [redux-thunk](https://github.com/reduxjs/redux-thunk/blob/master/src/index.js)\n\n"},{"slug":"currying","frontmatter":{"title":"柯里化-Currying","date":"June 23, 2021","description":null},"excerpt":"","content":"\n之前看 **Redux compose** 部分源代码的时候，就感觉和 **柯里化（Currying）** 很像，所以这篇把它安排上了，同属于函数式编程范畴。\n\n## What\n\n什么是柯里化（Currying）\n\n**柯里化** 大家应该听说过，或许还有些了解，但是到底什么样的范式才是柯里化呢？\n\n>在维基百科上的定义是这样：***currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument***.\n\n首先是一个技术，作用是将一个拥有多个参数的函数转化成一系列只能传入一个参数的函数。\n\n还是比较抽象，通过代码\n\n``` js\nconst add = (x) => (y) => x + y;\n```\n\n这种多 **=>** 的代码经常见，其实就是 **ES6** 版的柯里化，我们可以转化下\n\n觉得理解困难的可以借用 **[Babel](https://www.babeljs.cn/repl)** 来转化\n\n``` js\nvar add = function add(x) {\n  return function (y) {\n    return x + y;\n  };\n};\n```\n\n不用 **柯里化（Currying）**:\n\n``` js\nconst add = (a, b, c) => {\n  return a + b + c;\n}\n```\n\n在数学和计算机科学中的柯里化函数，一次只能传递一个参数；\n\n而我们 **Javascript** 实际应用中的柯里化函数，可以传递一个或多个参数。\n\n``` js\n//普通函数\nfunction fn(a, b, c, d, e) {\n  return a + b + c + d + e;\n}\n//生成的柯里化函数\nconst curryFn = curry(fn);\n\ncurryFn(1,2,3,4,5);     // 15\ncurryFn(1)(2)(3,4,5);   // 15\ncurryFn(1,2)(3,4)(5);   // 15\ncurryFn(1)(2)(3)(4)(5); // 15\n\n```\n\n那么什么时候应该用 **柯里化（Currying）** 呢，总不至于我们就是用来为了给三个数字求和。\n\n## When\n\n举个例子🌰\n\n科颜氏有一款爆火的爽肤水，经常会有活动促销打折，打折力度往往不一样\n\n所以他们会这样计算折后价格\n\n``` js\nconst discountPrice = (price, dicount) => {\n  return price * dicount;\n}\n\ndiscountPrice(300, 0.9);\ndiscountPrice(300, 0.95);\ndiscountPrice(300, 0.85);\ndiscountPrice(300, 0.88);\n```\n\n其实我们会发现，虽然折扣经常变，但是它本身的价格基本不变\n\n所以我们可以用 **柯里化（Currying）** 优化下代码结构\n\n``` js\nconst defaultPrice = 300; // 爽肤水默认价格\n\nconst discountPrice = (price) => {\n  return (dicount) => {\n    return price * dicount;\n  }\n}\n\n// const discountPrice = price => dicount => price * dicount\n\nconst tonerdDscountPrice = discountPrice(defaultPrice);\n\ntonerdDscountPrice(0.9);\ntonerdDscountPrice(0.95);\ntonerdDscountPrice(0.85);\ntonerdDscountPrice(0.88);\n```\n\n下面的代码是不是调用的时候更加舒爽一点\n\n## Why\n\n那么 **柯里化（Currying）** 有啥好处呢\n\n柯里化本质上是 ***降低通用性，提高适用性***。\n\n怎么理解...\n\n结合打折的例子看，\n\n降低通用性是指 **Currying** 之前，我们可以灵活的传入默认价格，我可以算出爽肤水折扣价格，也可以算出面膜折扣价格，很通用\n\n但是 **Currying** 之后更加适用于算出爽肤水折扣价格了，都不用传入默认价格了，提取了一个通用的方法对默认价格进行处理，只要传入折扣价格\n\n所以，关于使用其实是个取舍问题，需结合具体场景\n\n\n\n\n\n\n\n## 参考\n- [currying-javascript](https://www.dottedsquirrel.com/currying-javascript/)\n- [wiki-Currying](https://en.wikipedia.org/wiki/Currying)\n- [javascript-currying-what-is-the-point-of-currying-javascript-functions](https://www.jondjones.com/frontend/javascript/functional-programming/javascript-currying-what-is-the-point-of-currying-javascript-functions/)\n- [「前端进阶」彻底弄懂函数柯里化](https://juejin.cn/post/6844903882208837645)"},{"slug":"compose","frontmatter":{"title":"redux源码系列之compose","date":"June 23, 2021","description":null},"excerpt":"","content":"\n本来想写 **applyMiddleware** 方法代码解析的，然后一看，里面有个 **compose** 方法，好像内部代码也调用的比较多，想了想就决定先看下 **compose** 相关代码。\n\n``` javascript\nimport { compose } from 'redux'\n\nconst composeFn = compose(fn1, fn2, fn3, fn4)\nconst b = composeFn(x)\n// 等价于\nconst b = fn1(fn2(fn3(fn4(x))))\n```\n从使用上大概可以看出它的作用，从右往左的组合执行多个函数，将多个函数组合成一个函数，右边函数的执行结果是左边函数的参数值，\n除了最右边的函数可以传入多个参数，其余函数只能传入一个参数。\n\n## 参数\n1. **(arguments)**: 需要组合的函数。\n\n## 返回值\n**(Function)**: 从右到左把接收到的函数合成后的最终函数。\n\n## 代码结构\n代码算是很简单了，我们分两部分去理解\n\n### 上半部分\n\n``` typescript\nexport default function compose(): <R>(a: R) => R\n\nexport default function compose<F extends Function>(f: F): F\n\n/* two functions */\nexport default function compose<A, T extends any[], R>(\n  f1: (a: A) => R,\n  f2: Func<T, A>\n): Func<T, R>\n\n/* three functions */\nexport default function compose<A, B, T extends any[], R>(\n  f1: (b: B) => R,\n  f2: (a: A) => B,\n  f3: Func<T, A>\n): Func<T, R>\n\n/* four functions */\nexport default function compose<A, B, C, T extends any[], R>(\n  f1: (c: C) => R,\n  f2: (b: B) => C,\n  f3: (a: A) => B,\n  f4: Func<T, A>\n): Func<T, R>\n\n/* rest */\nexport default function compose<R>(\n  f1: (a: any) => R,\n  ...funcs: Function[]\n): (...args: any[]) => R\n\nexport default function compose<R>(...funcs: Function[]): (...args: any[]) => R\n\nexport default function compose(...funcs: Function[]) {\n  \n}\n```\n\n声明各种不同参数的 **compose**，其实是重载，为了写代码时有更好的代码提示。\n\n### 核心部分\n``` typescript\nreturn funcs.reduce(\n  (a, b) =>\n    (...args: any) =>\n      a(b(...args))\n)\n```\n最后 **compose return** 的是函数数组（即传入的参数）的 **reduce** 方法，显而易见的能组合成高阶函数的形式。\n\n## 总结\n\n``` javascript\ncompose(fn1, fn2, fn3, fn4)(...args) === fn1(fn2(fn3(fn4(...args))))\n```\n\n**compose** 函数在函数式编程里很常见。这里 **redux** 的对 **compose** 实现很简单，主要还是要对 **Array.prototype.reduce** 函数要熟练。\n\n"},{"slug":"createStore","frontmatter":{"title":"redux源码系列之createStore","date":"June 23, 2021","description":"深入源码解析createStore内部代码"},"excerpt":"","content":"\n``` javascript\nconst store = createStore(reducer, [initState, enhancer])\n```\n\n## 参数\n\n1. [**reducer**](https://redux.js.org/understanding/thinking-in-redux/glossary#reducer) (*Function*):  接受两个参数，分别是当前的 **state** 和要处理的 [**action**](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow#actions)\n\n2. [**preloadedState**] (*any*):  初始状态的 **state**，其实在实际开发中很少在这边给应用赋上初始 **state**，一般会在各自的 **reducer** 中赋上初始 **state**: \n\n``` javascript\nconst initialState = {}\n\n  // reducer\nconst todoApp = (state = initialState, action) => {\n  // 这里暂不处理任何 action，\n  // 仅返回传入的 state。\n  return state\n}\n```\n值得注意的是: 通常情况下，通过 **preloadedState** 指定的 **state** 要优先于通过 **reducer** 指定 **state** : \n\n``` javascript\nimport { createStore } from 'redux';\n// reducer\nconst a = (state = 'lol', action) => {\n  return state;\n}\n\nconst b = (state = 'wat', action) => {\n  return state;\n}\n\n// const combined = combineReducers({ a, b })\nconst combined = (state = {}, action) => {\n  return {\n    a: a(state.a, action),\n    b: b(state.b, action)\n  };\n}\n\nconst store = createStore(combined, { a: 'horse' });\nconsole.log(store.getState()); // { a: 'horse', b: 'wat' }\n```\n\n3. [**enhancer**] (*Function*):  高阶函数，通常是指中间件，必须用 **applyMiddleware()** 包装下：\n\n``` javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\n\nfunction logger({ getState }) {\n  return next => action => {\n    console.log('will dispatch', action)\n\n    // Call the next dispatch method in the middleware chain.\n    const returnValue = next(action)\n\n    console.log('state after dispatch', getState())\n\n    // This will likely be the action itself, unless\n    // a middleware further in chain changed it.\n    return returnValue\n  }\n}\n\nconst store = createStore(todos, applyMiddleware(thunk, logger))\n```\n\n## 返回值\n[**store**](https://redux.js.org/api/store): 是一个对象，包含了一些方法（[**dispatch**](https://redux.js.org/api/store#dispatchaction)，[**getState**](https://redux.js.org/api/store#getstate)等)，保存了应用所有 **state** 的对象。改变 **state** 的惟一方法是 **dispatch action**。\n\n``` typescript\nconst store = {\n  dispatch: dispatch as Dispatch<A>,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n} as unknown as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\nreturn store\n```\n\n## 代码结构\n便于理解，我们忽略函数中 **TS** 的一些类型定义，大致结构如下：\n\n``` javascript\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 传入参数的判断\n  // ...\n\n  // 参数中enhancer function存在，一般是指applyMiddleware()\n  if (typeof enhancer !== \"undefined\" && typeof enhancer === \"function\") {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  let currentReducer = reducer; // 当前store中的reducer\n  let currentState = preloadedState; // 当前store中存储的状态\n  let currentListeners = []; // 当前store中放置的监听函数\n  let nextListeners = currentListeners; // 下一次dispatch时的监听函数\n  let isDispatching = false; // 用于判断是否正在dispatch\n\n  // 获取state\n  function getState() {\n    //...\n  }\n\n  // 添加一个监听函数，每当dispatch被调用的时候都会执行这个监听函数\n  function subscribe() {\n    //...\n  }\n\n  // 触发了一个action，因此我们调用reducer，得到的新的state，并且执行所有添加到store中的监听函数。\n  function dispatch() {\n    //...\n  }\n\n  // 忽略两个不常用的方法replaceReducer，observable...\n\n  // createStore的时候会执行一次INIT action的dispatch\n  // 便于其他reducer获取初始值\n  dispatch({ type: ActionTypes.INIT } as A);\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    //下面两个是主要面向库开发者的方法，暂时先忽略\n    //replaceReducer,\n    //observable\n  };\n}\n```\n\n可以看出，**createStore** 方法创建了一个 **store**，但是并没有直接将这个 **store** 的状态 **state** 返回，而是返回了一系列方法，外部可以通过这些方法（**getState**）获取 **state**，或者间接地（通过调用 **dispatch** ）改变 **state**。\n\n下面我们来看下各个方法的具体实现\n\n### getState\n\n``` typescript\nfunction getState(): S {\n  // 如果正在dispath会抛出异常\n  if (isDispatching) {\n    throw new Error(\n      'You may not call store.getState() while the reducer is executing. ' +\n        'The reducer has already received the state as an argument. ' +\n        'Pass it down from the top reducer instead of reading it from the store.'\n    )\n  }\n\n  return currentState as S\n}\n```\n\n很简单，就是获取当前 **state**，我们可以通过 ``` store.getState() = ... ``` 来修改 **state**，但是一般来说，redux不建议这样做，只能通过 **dispatch action** 来修改 **state**。\n\n### subscribe\n\n``` typescript\n  // 若相等，做一下currentListeners浅拷贝\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  function subscribe(listener: () => void) {\n    if (typeof listener !== 'function') {\n      // throw Error\n    }\n    if (isDispatching) {\n      // throw Error\n    }\n    //设置一个标志，标志该监听器已经订阅了\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    // push到nextListeners数组中，下次dispatch会调用\n    nextListeners.push(listener)\n\n    // 返回了一个取消订阅的函数，即从数组中删除该监听函数\n    return function unsubscribe() {\n      // 如果已经取消订阅过了，直接返回\n      if (!isSubscribed) {\n        return\n      }\n      if (isDispatching) {\n        // throw Error\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      // 从下一轮的监听函数数组（用于下一次dispatch）中删除这个监听器。\n      const index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n      // 清空当前currentListeners\n      currentListeners = null\n    }\n  }\n```\n\n### dispatch\n\n``` typescript\nfunction dispatch(action: A) {\n  if (!isPlainObject(action)) {\n    // throw Error\n  }\n\n  if (typeof action.type === 'undefined') {\n    // throw Error\n  }\n\n  if (isDispatching) {\n    // throw Error\n  }\n\n  try {\n    // 标记正在dispatch\n    isDispatching = true\n    // 调用reducer，得到新state\n    currentState = currentReducer(currentState, action)\n  } finally {\n    isDispatching = false\n  }\n\n  const listeners = (currentListeners = nextListeners)\n  // 遍历执行监听数组中的所有监听函数\n  for (let i = 0; i < listeners.length; i++) {\n    const listener = listeners[i]\n    listener()\n  }\n\n  // 返回传入的action\n  return action\n}\n```\n\n**dispatch** 是修改 **state** 的唯一途径（**redux** 规定）。\n\n## 总结\n整个 **createStore** function 还是比较容易理解的，记住应用中应有且仅有一个 store。\n\n## 参考\n- [Redux createStore API](https://redux.js.org/api/createstore)\n- [Redux createStore API（中文版）](https://www.redux.org.cn/docs/api/createStore.html)\n"},{"slug":"RESTful","frontmatter":{"title":"RESTful资源命名规范","date":"June 8, 2021","description":"资源路径如何正确的定义？应该遵守怎样的命名规范？"},"excerpt":"","content":"\n在 **REST** 中，主要的数据描述称为 **Resource**，拥有明确一致的 **REST** 命名规范，长期来看将是最好的决策\n\n> 资源可以是单例或者集合，比如说，customers是一个集合资源，customer是一个单个资源。我们在URI中可以用\"/customers\"来定义集合资源，用\"/customers/{customerId}\"来定义单个资源。\n\n> 一个资源也可以包含子集合资源，比如说，一个顾客他名下有多个account，我们可以这样\"/customers/{customerId}/accounts\"表示。相同的，单独表示某个顾客的某个账号，我们可以这样\"/customers/{customerId}/accounts/{accountId}\"。\n\n## Tips\n1. 使用名词表示资源（而不是动词）\n\n\n2. 使用\"/\"表示层次关系\n\n```url\nhttp://api.example.com/customers/{customerId}/accounts/{accountId}\n```\n\n\n3. 结尾不需要加\"/\"\n\n```url\nhttp://api.example.com/device-management/managed-devices/\n\n//better\nhttp://api.example.com/device-management/managed-devices\n```\n\n4. 用\"-\"代替驼峰的命名方式，提高可读性,\n   也不要使用下划线\"_\"（某些字体下会显示不明显，或者被遮盖）\n\n```url\nhttp://api.example.com/inventoryManagement/managedEntities/{id}/installScriptLocation \n\nhttp://api.example.com/inventory_management/managed_entities/{id}/install_script_location\n\n//better\nhttp://api.example.com/inventory-management/managed-entities/{id}/install-script-location\n```\n\n5. 使用小写字母\n\n\n6. 不要加文件后缀\n\n```url\nhttp://api.example.com/device-management/managed-devices.xml  /*Do not use it*/\n\nhttp://api.example.com/device-management/managed-devices \t/*This is correct URI*/\n```\n\n7. 不要使用CRUD的一些方法名词（例如：getXXX，deletXXX，与第一点类似）\n\n```url\nHTTP GET http://api.example.com/device-management/managed-devices  //Get all devices\nHTTP POST http://api.example.com/device-management/managed-devices  //Create new Device\n\nHTTP GET http://api.example.com/device-management/managed-devices/{id}  //Get device for given Id\nHTTP PUT http://api.example.com/device-management/managed-devices/{id}  //Update device for given Id\nHTTP DELETE http://api.example.com/device-management/managed-devices/{id}  //Delete device for given Id\n```\n\n\n8. 用query形式来过滤资源集合（区别于params形式，理解）\n```url\nhttp://api.example.com/device-management/managed-devices\n\nhttp://api.example.com/device-management/managed-devices?region=USA\nhttp://api.example.com/device-management/managed-devices?region=USA&brand=XYZ\nhttp://api.example.com/device-management/managed-devices?region=USA&brand=XYZ&sort=installation-date\n```\n\n\n## 参考：\n- [resource-naming](https://restfulapi.net/resource-naming)\n"},{"slug":"sass-summary","frontmatter":{"title":"Sass总结篇","date":"June 7, 2021","description":"Sass的常用功能总结"},"excerpt":"","content":"\n以前只用过嵌套和变量，所以在脑子里CSS预处理器就这点功能。\n\n最近准备看下Sass文档，学习和总结下，看了中文文档有些翻译确实让人看不太懂，所以决定对着英文文档自己啃。\n\n本准备像上一篇一样，把英文文档逐篇翻译，后来想想算了，所以总结了Sass常用的一些功能点。\n\n## 变量\n\n变量以 **$** 开头，非驼峰写法，以 **-** 做命名切割\n\n![sass-variable](sass-variable.jpeg)\n\n⚠️**注意**：原生CSS也是带有变量功能的，命名以 **--** 开头，点击[这里](https://sass-lang.com/documentation/variables)查看具体的区别\n\n\n## 嵌套\n\n原生CSS是不支持嵌套写法的，但有个相关的[草案](https://drafts.csswg.org/css-nesting-1)，相信不久的将来也会支持\n\n![sass-css-nesting](sass-css-nesting.jpeg)\n\n用Sass我们可以这样写\n\n![sass-css-nesting](sass-nesting.jpeg)\n\n嵌套写法也是我们大部分人最常用的功能，没有之一。。。\n\n⚠️**注意**：嵌套是很有用，但也是很容易滥用的地方，一般建议嵌套不超过三层，否则会影响性能，在Sass中还提供了一个[@at-root](https://sass-lang.com/documentation/at-rules/at-root) 的功能，可以让你直接跳出去。这样也可以避免嵌套层级过深。\n\n\n## 父选择器（&）\n\n在嵌套中，我们用 **&** 来表示当前位置的父类节点，通常在写伪类的时候会用到\n\n![sass-&](sass-&.jpeg)\n\n## 占位符选择器（placeholder）\n\n占位符选择器以 **%** 开头，通过 **@extend** 来应用\n\n![sass-placeholder](sass-placeholder.jpeg)\n\n编译出来的CSS代码中并不会包括 **%placeholder** 规则中的样式，除非是通过 **@extend** 对其进行调用\n\n它和 **mixin** 的使用也很像，但是还是有区别\n\n### mixin\n\n![sass-placeholder-mixin](sass-placeholder-mixin.jpeg)\n\n### placeholder\n\n![sass-placeholder1](sass-placeholder1.jpeg)\n\n## 继承（@extend）\n\n所谓 **@extend** 用法就是你为通用样式写一个 **.** 样式类，然后要用到改样式的地方再 **@extend**\n\n![sass-extend](sass-extend.jpeg)\n\n我们可以从上图中很直接的看出它与 **%placeholder** 的区别\n\n还有一个问题，**.icon** 类我们在 **Html** 中不会用到，因为它仅仅是用来被 **@extend** 的，我们可以使用 **%placeholder** 来解决这种现象\n\n## mixin\n\n**mixin** 前面介绍占位符的时候也稍待介绍下，它主要用来修饰 **function** ，可以传入参数，也可以给参数设置个默认值\n\n![sass-mixin](sass-mixin.jpeg)\n\n## SassScript相关\n\n### @if和@else\n\n流程控制指令一般会配合 **mixin** 一起使用\n\n![sass-if-else](sass-if-else.jpeg)\n\n### @for\n\n![sass-for](sass-for.jpeg)\n\n\n### @while\n\n![sass-while](sass-while.jpeg)\n\n\n## 参考\n- [掌握sass这些技能，帮助提升开发效率](https://juejin.cn/post/6870009638478151688)\n- [your-nesting-is-harmful](https://medium.com/@verpixelt/your-nesting-is-harmful-a1ffddaf7e43)\n- [your-placeholder-selectors](https://sass-lang.com/documentation/style-rules/placeholder-selectors)\n\n\n\n"},{"slug":"sass-syntax","frontmatter":{"title":"Sass语法篇","date":"May 28, 2021","description":"Sass的基本语法，以及语法声明和表达式介绍"},"excerpt":"","content":"\n## Sass支持两种语法，你可以根据喜好随意选择其中一种。\n\n## SCSS\n\nSCSS语法应用于后缀为 **.scss** 的文件，它是CSS的超集，那就意味着大多数情况下 ***合法的CSS写法也适用于SCSS***。\n\n\n``` css\n@mixin button-base() {\n  @include typography(button);\n  @include ripple-surface;\n  @include ripple-radius-bounded;\n\n  display: inline-flex;\n  position: relative;\n  height: $button-height;\n  border: none;\n  vertical-align: middle;\n\n  &:hover { cursor: pointer; }\n\n  &:disabled {\n    color: $mdc-button-disabled-ink-color;\n    cursor: default;\n    pointer-events: none;\n  }\n}\n```\n\n\n## 缩进式语法（SASS）\n\n这是Sass最原先的语法，应用于后缀为 **.sass** 的文件，缩进语法支持SCSS语法的一眼的功能，只是在写法上会用缩进的形式代替花括号和分号。\n\n通常来讲，你如果想用花括号来表示结构的时候，你可以使用代码缩进来表示，每行结束的时候，即视为分号，这里只包括了基本的写法区别，其余的区别在后续的文档中会提到\n\n\n```css\n@mixin button-base()\n  @include typography(button)\n  @include ripple-surface\n  @include ripple-radius-bounded\n\n  display: inline-flex\n  position: relative\n  height: $button-height\n  border: none\n  vertical-align: middle\n\n  &:hover\n    cursor: pointer\n\n  &:disabled\n    color: $mdc-button-disabled-ink-color\n    cursor: default\n    pointer-events: none\n```\n\n## 和CSS一样，大部分Sass样式表是由包含属性声明的样式规则组成。但是Sass样式表还包含其他的一些功能\n\n## 声明\n\nSass样式表由一系列声明组成，一些声明会包含语法块，通常由 **{}** 表示，语法块中还会包含其他声明，例如属性声明。\n\n在Scss中，声明由分号分隔开，在缩进语法（.sass）中，只需换行即可。\n\n### 通用声明\n\n这些声明可以在Sass样式表中任何地方使用：\n\n- [变量声明](https://sass-lang.com/documentation/variables)，比如： **$var: value**\n- [流程控制规则](https://sass-lang.com/documentation/at-rules/control)，比如： **@if** and **@each**\n- [@error](https://sass-lang.com/documentation/at-rules/error)，[@warn](https://sass-lang.com/documentation/at-rules/warn) 和 [@debug](https://sass-lang.com/documentation/at-rules/debug)规则\n\n### CSS声明\n\n这些声明生成CSS，它们可以在除 **@function** 的任何地方使用：\n- [Style规则](https://sass-lang.com/documentation/style-rules)，比如 **h1 { /* ... */ }**\n- [CSS规则](https://sass-lang.com/documentation/at-rules/css)，比如 **@media** 和 **@font-face**\n- [Mixin](https://sass-lang.com/documentation/at-rules/mixin)使用 **@include**\n- [@at-root规则](https://sass-lang.com/documentation/at-rules/at-root)\n\n### 顶级声明\n\n这些声明只能在样式表最上面或者CSS语法块最外层使用：\n- [模块加载](https://sass-lang.com/documentation/at-rules/use)，使用 **@use**\n- [引入](https://sass-lang.com/documentation/at-rules/import)，使用 **@import**\n- [Mixin定义](https://sass-lang.com/documentation/at-rules/mixin)，使用 **@mixin**\n- [Function定义](https://sass-lang.com/documentation/at-rules/function)，使用 **@function**\n\n### 其余声明\n- [属性声明](https://sass-lang.com/documentation/style-rules/declarations)，比如 **width: 100px** 只能在 **Style规则** 和 **CSS规则** 中使用\n- [@extend规则](https://sass-lang.com/documentation/at-rules/extend)只能在 **Style规则** 中使用\n\n## 表达式\n\n表达式通常指属性右侧部分或者是变量声明，所有表达式最后都会生成一个值。任何有效的CSS属性值都可以是Sass表达式，但是Sass表达式包含更丰富强大的功能。它们可以将参数传递给 **mixins** 和 **functions**，用 **@if rule** 控制流程，并用算法进行操作。我们把Sass表达式称为 **SassScript** 语法。\n\n### 文值\n\n最简单的表达式就是静态的值：\n- [Numbers](https://sass-lang.com/documentation/values/numbers)，可以有单位，比如 **12** 或 **100px**\n- [Strings](https://sass-lang.com/documentation/values/strings)，可以有引号，比如 **\"Helvetica Neue\"** 或 **blod**\n- [Colors](https://sass-lang.com/documentation/values/colors)，可以用颜色代码或者颜色名表示，比如 **#c6538c** 或 **blue**\n- [boolean](https://sass-lang.com/documentation/values/booleans)， **true** 或者 **false**\n- [null](https://sass-lang.com/documentation/values/null)\n- [值列表](https://sass-lang.com/documentation/values/lists)，由空格，逗号或者 **[]** 来隔开，比如：**1.5em 1em 0 2em, Helvetica, Arial, sans-serif** 或者 **[col1-start]**\n- [Maps](https://sass-lang.com/documentation/values/maps)会把 **key** 和 **value** 联系起来，比如： **(\"background\": red, \"foreground\": pink)**\n\n### 运算\n\nSass为数字运算定义了语法：\n- [== 和 !=](https://sass-lang.com/documentation/operators/equality)用来检查两个值是否相等\n- [+, -, *, /, 和 %](https://sass-lang.com/documentation/operators/numeric)用来对数字进行常用的算数计算，加上单位会有特殊的意义\n- [<, <=, >, 和 >=](https://sass-lang.com/documentation/operators/relational)用来检查两个值哪个大，哪个小\n- [and, or 和 not](https://sass-lang.com/documentation/operators/boolean)用来表示布尔行为，Sass认为除了 **false** 和 **null** 其余的都为 **true**\n- [+, - 和 /](https://sass-lang.com/documentation/operators/string)可用于连接字符串\n- [( and )](https://sass-lang.com/documentation/operators#parentheses)可用于显式控制操作的优先顺序\n\n\n### 其余表达式\n- [变量](https://sass-lang.com/documentation/variables)，比如 **$var**\n- [函数调用](https://sass-lang.com/documentation/at-rules/function)，比如 **nth($list, 1)** 或者 **var(--main-bg-color)** ，可以调用Sass核心库函数或用户定义的函数，也可以直接编译为CSS\n- [特定函数](https://sass-lang.com/documentation/syntax/special-functions)，比如 **calc(1px + 100%)**，**url(http://myapp.com/assets/logo.png)** 具有自己独特的解析规则\n- [父级选择器](https://sass-lang.com/documentation/style-rules/parent-selector)， **&**\n- **!important**，被解析为无引号的字符串\n\n\n## 参考\n- [sass-syntax](https://www.freecodecamp.org/news/npm-vs-npx-whats-the-difference/)"},{"slug":"npm-vs-npx","frontmatter":{"title":"npx是什么","date":"May 26, 2021","description":"npx和npm的区别是啥，npx能解决npm的哪些痛点"},"excerpt":"","content":"\n\n如果你曾经用过Node.js，那你一定用过npm。\n\n**npm**(node package manager)是你安装Node.js之后开箱即用的包依赖管理工具。开发者可以通过它本地或全局安装依赖库。\n\n有时候你可能只是想了解下某些库，然后试一试它的一些命令，但是你不在本地  **node_modules**  文件夹安装相关的库你是无法尝试它的指令的。\n\n这就是 **npx** 出现的原因。\n\n本文我们讲着重看一看两者的区别，学会在合适的场景使用它们。\n\n首先，让我们先来了解下 **npm** 到底是什么，我们可以通过它来干些啥。\n\n## npm the package manager\n\n它是一个在线资源库，用于发布开源的Node.js项目\n\n它是一个CLI（命令行）工具，可以帮助你安装库并管理其版本和依赖（npm上又成千上万的Node.js库和应用，而且每天都在增加）\n\nnpm本身不会运行任何库，如果你想使用npm来运行某些库，你必须要在你的 **package.json** 文件中声明\n\n当npm执行安装库的指令时（npm install xxx)，npm会创建指向它们的链接\n1. 本地安装会在 **./node_modules/.bin/** 文件夹中创建链接\n2. 全局安装会在全局的 **bin/** 文件夹下创建链接（例如：Linux系统是 **/usr/local/bin** ，Windows系统是 **%AppData%/npm** ）\n\n你可以这样执行库\n\n``` bash\n$ ./node_modules/.bin/your-package\n```\n或者可以通过在package.json里添加脚本来执行\n\n``` json\n{\n  \"name\": \"your-application\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"your-package\": \"your-package\"\n  }\n}\n```\n然后你可以运行指令：\n\n``` node\nnpm run your-package\n```\n\n你可以看到通过 **npm** 运行库还是要花不少时间的。\n\n庆幸的是，**npx** 可以派上用场了。\n\n## npm the package runner\n\n从 **npm**5.2.0版本开始，安装 **npm** 会预安装上 **npx**。\n\n**npx** 也是CLI（命令行）工具，其目的是使得安装和管理 **npm** 依赖库更加容易。\n\n现在可以很简单的运行通过 **npm** 安装的任何基于Node.js的可执行文件。\n\n你可以通过以下指令查看你当前 **npm** 版本是否已经安装了 **npx** ：\n\n``` dash\n$ which npx\n```\n如果没有，可以通过以下指令安装：\n``` dash\n$ npm install -g npx\n```\n\n确定安装好之后，我们通过一些用例来看看 **npx** 是多么的方便有用。\n\n## Run a locally installed package easily\n\n如果要执行本地安装的库，只需输入：\n``` dash\n$ npx your-package\n```\n**npx** 将检查 **$ PATH** 或本地项目二进制文件中是否存在 **<command>** 或 **<package>** ，如果存在，它将执行该命令。\n\n## Execute packages that are not previously installed\n\n另一个主要优点是能够执行未安装的库。\n\n有时，您只是想使用某些库的命令行指令，但不想安装它们。 这意味着你可以节省一些磁盘空间，仅在需要它们时才安装它们。\n\n## Run code directly from GitHub\n\n![execute-gist-scripts-with-npx](execute-gist-scripts-with-npx.jpeg)\n\n这很酷！\n\n你可以使用 **npx** 运行任何 **GitHub gists** 和仓库。 让我们集中精力执行 **GitHub gists** ，因为它更容易创建。\n\n在[这里](https://gist.github.com/Tynael/0861d31ea17796c9a5b4a0162eb3c1e8)，你可以找到此示例代码。\n\n在执行之前，请确保仔细阅读所有 script，以避免由于恶意代码而导致的严重问题。\n\n## 总结\n\n**npx** 帮助我们避免安装仅仅想尝试的不必要的库\n\n它还提供了一种通过直连 **GitHub gists** 或 **仓库** 来执行包命令的更简单快捷的方式\n\n如果您以前从未使用过 **npx**，那么现在是开始的好时机！\n\n## 参考\n- [npm-vs-npx-whats-the-difference](https://www.freecodecamp.org/news/npm-vs-npx-whats-the-difference/)"}]},"__N_SSG":true}