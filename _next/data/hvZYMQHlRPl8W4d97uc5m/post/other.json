{"pageProps":{"frontmatter":{"title":"面试题集合（其他）","date":"July 11, 2021","description":null},"post":{"content":"\n## 1. 前端之SSO（单点登录）\n\n### 知识点\n- session存储用户信息于服务器\n- 通过session ID（cookie）来实现认证\n- 由于cookie不支持跨域，跨域时的解决方案不同于同域\n\n### 链接\n- [单点登录（SSO）看这一篇就够了](https://www.jianshu.com/p/75edcc05acfd)\n- [前端需要了解的 SSO 与 CAS 知识](https://juejin.cn/post/6844903509272297480)\n  \n## 2. git revert和reset\n\n- git reset操作会将版本回退至指定的commit，指定commit后的操作都将被撤销\n- git revert则撤销指定commit的修改，同时生成一个新的commit\n\n## 3. git merge和rebase\n\n![git merge](git-merge.jpeg)\n![git rebase](git-rebase.jpeg)\n\n- 都是合并操作\n- 当需要保留详细的合并信息的时候建议使用git merge，特别是需要将分支合并进入master分支时；\n- 当发现自己修改某个功能时，频繁进行了git commit提交时，发现其实过多的提交信息没有必要时，可以尝试git rebase\n- rebase操作会去除之前的commit记录，而merge不会\n\n### cherrypick的了解\n\n## 4. git 如何取消add操作\n\n可以reset，reset后面可以跟commit ID，也可以跟Head指针回退add内容\n\n## 5. git的工作流\n\ndev、release、master分支\n\n## 6. keepAlive组件的原理\n\n\n","excerpt":""},"previousPost":{"slug":"browser","frontmatter":{"title":"面试题集合（浏览器篇）","date":"July 6, 2021","description":null},"excerpt":"","content":"\n## 1. 浏览器存储\n\n### Cookie\n\n- 大小限制4k，超出会裁剪\n\n- HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）\n  \n- cookie 存储在客户端\n  \n  cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\n\n- cookie 是不可跨域的\n  \n### LocalStorage\n\n- 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据\n- 大小为5M左右\n- 仅在客户端使用，不和服务端进行通信\n\n### sessionStorage\n\n- 会话级别的浏览器存储（窗口关闭会清空）\n- 大小为5M左右\n- 仅在客户端使用，不和服务端进行通信\n  \n基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。\n\n### sessionStorage 、localStorage 和 cookie 之间的区别\n\n- 共同点：都是保存在浏览器端，且都遵循同源策略。\n- 不同点：在于生命周期与作用域的不同"},"nextPost":{"slug":"easy","frontmatter":{"title":"算法题（简单系列）","date":"July 12, 2021","description":null},"excerpt":"","content":"\n## 1. 两数之和\n\n### 题目描述\n\n给定一个整数数组 **nums** 和一个目标值 **target**，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n### 示例\n\n``` javascript\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n````\n\n### 代码实现\n\n``` javascript\nconst findTotal = (nums, target) => {\n  for(let i = 0; i < nums.length; i++) {\n    if (nums.includes(target-nums[i])) {\n      return [i, nums.indexOf(target-nums[i])];\n    }\n  }\n}\n```\n\n\n## 2. 整数反转\n\n### 题目描述\n\n![reverse-integer](reverse-integer.jpeg)\n\n\n### 代码实现\n\n``` javascript\nconst reverse = (x) => {\n  let result = 0;\n  while (x !== 0) {\n    result = result * 10 + (x % 10);\n    x = Math.floor(x / 10);\n  }\n\n  if (result < -Math.pow(2, 31) || result > Math.pow(2, 31) - 1) {\n    return 0;\n  }\n  return result;\n};\n```\n\n## 3. 合并两个有序链表\n\n### 题目描述\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n### 示例1\n\n![merge-two-sorted-lists](merge-two-sorted-lists.jpeg)\n\n``` javascript\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n### 示例2\n\n``` javascript\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n### 示例3\n\n``` javascript\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n### 提示\n\n- 两个链表的节点数目范围是 [0, 50]\n- -100 <= Node.val <= 100\n- l1 和 l2 均按 非递减顺序 排列\n\n``` javascript\n// 例如 现有两个链表\nconst ListNode1 = {\n  value: 0,\n  next: {\n    value: 2,\n    next: {\n      value: 4,\n      next: null\n    }\n  }\n}\n\nconst ListNode2 = {\n  value: 1,\n  next: {\n    value: 3,\n    next: {\n      value: 5,\n      next: null\n    }\n  }\n}\n```\n\n### 实现\n\n``` javascript\nconst mergeTwoLists = (l1, l2) => {\n  if (l1 === null) {\n    return l2\n  }\n  if (l2 === null) {\n    return l1\n  }\n  if (l1.value < l2.value) {\n    l1.next = mergeTwoLists(l1.next, l2)\n    return l1\n  }\n  if (l2.value < l1.value) {\n    l2.next = mergeTwoLists(l2.next, l1)\n    return l2\n  }\n}\n```\n\n## 4. 最大子序和\n\n### 题目描述\n\n给定一个整数数组 **nums** ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n### 示例1\n\n``` javascript\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n### 示例2\n\n``` javascript\n输入：nums = [1]\n输出：1\n```\n\n### 示例3\n\n``` javascript\n输入：nums = [0]\n输出：0\n```\n\n### 示例4\n\n``` javascript\n输入：nums = [-1]\n输出：-1\n```\n\n### 示例5\n\n``` javascript\n输入：nums = [-100000]\n输出：-100000\n```\n\n### 提示\n- 1 <= nums.length <= 3 * 104\n- -105 <= nums[i] <= 105\n\n``` javascript\nconst maxSubArray = (nums) => {\n  let pre = 0;\n  let max = nums[0];\n  nums.forEach(x => {\n    pre = Math.max(pre + x, x);\n    max = Math.max(max, pre);\n  });\n  return max;\n};\n```\n\n## 5. 反转链表\n\n### 题目描述\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n### 示例:\n\n``` javascript\nconst ListNode = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: {\n          value: 5,\n          next: null\n        }\n      }\n    }\n  }\n}\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n### 限制：\n\n``` javascript\n0 <= 节点个数 <= 5000\n```\n\n``` javascript\nconst reverseList = (head) => {\n  let pre = null;\n  let cur = head;\n  while(cur) {\n    const next = cur.next;\n    cur.next = pre;\n    pre = cur;\n    cur = next;\n  }\n  return pre;\n}\n```\n\n## 6. 二叉树的最大深度\n\n### 题目描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明： 叶子节点是指没有子节点的节点。**\n\n### 示例\n\n给定二叉树 **[3,9,20,null,null,15,7]**\n\n![maximum-depth-of-binary-tree](maximum-depth-of-binary-tree.jpeg)\n\n返回它的最大深度 3 。\n\n``` javascript\nconst maxDepth = tree => {\n  if (!tree) {\n    return 0;\n  }\n  const maxLeft = maxDepth(tree.left);\n  const maxRight = maxDepth(tree.right);\n  return Math.max(maxLeft, maxRight) + 1;\n}\n```\n\n## 7. 环形链表\n\n### 题目描述\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n### 思路\n\n给遍历过的节点打记号，如果遍历过程中遇到有记号的说明已环🤓\n\n``` javascript\nconst hasCycle = head => {\n  while(head) {\n    if (head.tag) {\n      return true;\n    }\n    head.tag = true;\n    head = head.next;\n  }\n  return false;\n}\n```\n\n\n## 8. 合并二叉树\n\n### 题目描述\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n### 示例\n\n![merge-two-binary-trees](merge-two-binary-trees.jpeg)\n\n**注意：合并必须从两个树的根节点开始。**\n\n``` javascript\nconst mergeTrees = (t1, t2) => {\n  if (!t1 || !t2) {\n    return t1 || t2;\n  }\n  t1.value = t1.value + t2.value;\n  t1.left = mergeTrees(t1.left, t2.left);\n  t1.right = mergeTrees(t1.right, t2.right);\n  return t1;\n}\n```\n\n"}},"__N_SSG":true}