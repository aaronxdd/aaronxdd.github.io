{"pageProps":{"frontmatter":{"title":"面试题集合（CSS篇）","date":"July 16, 2021","description":null},"post":{"content":"\n## 1. css 伪类与伪元素区别\n   \n### 伪类(pseudo-classes)\n\n其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。⽐如:hover :active :visited :link :visited :first-child :focus :lang等；由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。\n  \n### 伪元素(Pseudo-elements)\n\nDOM树没有定义的虚拟元素\n\n核⼼就是需要创建通常不存在于⽂档中的元素，⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器\n    \n### 伪类与伪元素的区别\n    \n表示⽅法\n\nCSS2 中伪类、伪元素都是以单冒号:表示,CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头定义不同\n\n伪类即假的类，可以添加类来达到效果\n\n伪元素即假元素，需要通过添加元素才能达到效果\n    \n总结:\n\n伪类和伪元素都是⽤来表示⽂档树以外的\"元素\"。伪类和伪元素分别⽤单冒号:和双冒号::来表示。伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。\n\n### 相同之处：\n\n伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。\n  \n### 不同之处：\n    \n伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。\n\n## 2. position\n\n- static： 默认值。没有定位，元素出现在正常的流中（top, right, bottom, left 和 z-index 属性无效）\n- relative： 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）\n- absolute： 元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的 **非 static** 定位祖先元素的偏移，来确定元素位置。\n- fixed： 元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。\n\n## 3. 水平垂直居中\n\n- 定宽居中\n  \n  - absolute+负maigin\n  ``` css\n  .father {\n      width: 400px;\n      height: 400px;\n      border: 1px solid blue;\n      position: relative;\n  }\n  \n  .son {\n      width: 100px;\n      height: 100px;\n      background-color: orange;\n      /* 1、定宽高定位：absolute + 负边距margin */\n      position: absolute;\n      top: 50%;\n      left: 50%;\n      margin-top: -50px;\n      margin-left: -50px;\n  }\n  ```\n\n  - absolute+maigin:auto\n  ``` css\n  .father {\n      border: 1px solid red;\n      width: 300px;\n      height: 300px;\n      position: relative;\n  }\n  \n  .son {\n      width: 100px;\n      height: 100px;\n      background: green;\n      /*2、定宽高定位：absolute + margin:auto */\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      margin: auto;\n  }\n  ```\n\n- 不定宽居中\n\n  - absolute+transform\n\n  ``` css\n  .father {\n      border: 1px solid red;\n      width: 300px;\n      height: 300px;\n      position: relative;\n  }\n  \n  .son {\n      background: green;\n      /* 1、不定宽高居中：（依赖translate 2d的兼容性）absolute+transform */\n      position: absolute;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n  }\n  ```\n\n  - lineheight（行内元素）\n\n  ``` css\n  .father {\n      border: 1px solid red;\n      width: 300px;\n      height: 300px;\n      /* 2、不定宽高居中  */\n      text-align: center;\n      line-height: 300px;\n      font-size: 0px;\n  }\n  \n  .son {\n      /* 2、不定宽高居中lineheight */\n      display: inline-block;\n      vertical-align: middle;\n      line-height: inherit;\n      text-align: left;\n      font-size: 16px;\n  }\n  ```\n\n  - flex布局\n\n  ``` css\n  .father {\n      border: 1px solid red;\n      width: 300px;\n      height: 300px;\n      /* 4、不定宽高居中flex */\n      display: flex;\n      justify-content: center;\n      align-items: center;\n  }\n  ```\n\n  - grid布局\n\n  ``` css\n  .father {\n      border: 1px solid red;\n      width: 300px;\n      height: 300px;\n      /* 5、grid */\n      display: grid;\n  }\n  \n  .son {\n      /* 5、不定宽高居中grid(兼容性不如flex 不推荐使用) */\n      justify-self: center;\n      align-self: center;\n  }\n  ```\n## 4. link和@import的区别？\n\n- link 属于 XHTML 标签，⽽ @import 是 CSS 提供的。\n- ⻚⾯被加载时，link 会同时被加载，⽽ @import 引⽤的 CSS 会等到⻚⾯被加载完再加载。\n- link ⽅式的样式权重⾼于 @import 的权重。\n  \n## 5. em\\px\\rem区别\n\n- em：在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width\n- rem：根元素的字体大小（html的font-size)\n- px：绝对单位，⻚⾯按精确像素展示\n\n\n\n","excerpt":""},"previousPost":{"slug":"questions","frontmatter":{"title":"面试题集合（真题篇）","date":"July 16, 2021","description":null},"excerpt":"","content":"\n## 1. 性能优化 ：项⽬⾥做过哪些性能优化，怎么检测性能，有没有实际测过优化的数据有多少提升\n  ![性能优化](performance.jpeg)\n\n### 性能优化\n\n- 避免过多的回流与重绘\n  \n  实质上是避免过多的 **render tree** 操作，避免使用table布局；DOM结构避免嵌套过深\n\n- JavaScript、Css、Html压缩\n- splitChunks 拆包\n- 网页中可视化部分（图片，视频等）采用骨架\n- 函数的频繁调用考虑使用防抖节流\n- 多利用缓存（多跟服务器端有关）\n- 大的基础库使用CDN\n- 用上懒加载和预加载\n- 使用Service Worker\n  \n### 检测性能\n\n- 很直观的看network页面的load时间\n- lighthouse进行检测\n- 用webpack-bundle-analyzer查看打包后资源情况\n  \n## 2. http2.0有哪些特性？https是怎么加密的，https强缓存在项目中怎么用的\n\n### http2.0的特性\n- 二进制分帧\n\n  HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率\n\n- 多路复用\n  \n  一次链接成功后，只要链接还没断开，那么 client 端就可以在一个链接中**并发**地发起多个请求，每个请求及该请求的响应不需要等待其他的请求，某个请求任务耗时严重，不会影响到其它连接的正常执行\n\n- 头部压缩\n  \n  由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源\n\n### HTTP 与 HTTPS\n\n- HTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密\n- HTTP 的端口号是 80，HTTPS 是 443\n- HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费\n- HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\n### 浏览器缓存策略\n\n## 3. web安全（xss/csrf）\n\n### xss（Cross-Site Scripting）\n\n**定义**\n\n跨站脚本攻击，简称脚本注入\n\n**原理**\n\n恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n\n**防范**\n\n- HttpOnly 防止劫取 Cookie，浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\n- 输入检查，对 **<**  、 **>** 进行转译，使得恶意的脚本内容无法执行（React DOM 会在渲染的时候把内容（字符串）进行转义）\n\n\n### csrf\n\n**定义**\n\n跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式\n\n**原理**\n\n利用同域下cookie可以共享，在A页面中嵌入B页面的请求，如果用户登录过B页面，即在A中的B请求可以获取B服务器信任。\n\n**防范**\n\n- Token验证\n\n## 4. 前端能在Http缓存上做哪些优化\n\n- 对于经常不改动的静态资源可以在 nginx 上增加相关的缓存配置，尽可能的命中强缓存\n- 正确使用好前端资源打包的 hash\n- Service Worke 也可以针对缓存做一些优化"},"nextPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"July 17, 2021","description":null},"excerpt":"","content":"\n## 1. infinity代表什么数据\n\n  在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n## 2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n## 3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\n- new String(\"A\") :\n  \n  返回类型：引用类型，堆内存存储\n  返回值：字符串对象\n\n- String(\"A”) ：\n  \n  返回类型：基本类型，栈内存存储\n  返回值：字符串值\n\n## 4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr => arr.reduce((a, b) => a + b)\n```\n\n## 5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n## 6. 图片懒加载原理\n   \n  图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n``` js\nlet imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\n// 修正错误，需要加上自执行\n- const imgLazyLoad = function() {\n+ const imgLazyLoad = (function() {\n    let count = 0\n    \n   return function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) => {\n            let rect = img.getBoundingClientRect()\n            if (rect.top < window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) => !deleteIndexList.includes(index))\n   }\n- }\n+ })()\n\n// 这里最好加上节流处理\ndocument.addEventListener('scroll', imgLazyLoad)\n\n```\n\n## 7. 懒加载和预加载\n\n  两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n## 8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n## 9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' && /native code/.test(f.toString())\n}\n```\n\n## 10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n  js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n## 11. 函数的方法 call()、apply()、bind()的区别\n\n### 改变函数执行上下文，也就是改变this的指向\n\n- call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。\n- call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n\n## 12. 前端性能优化\n- 减少 HTTP 请求\n- 使用 HTTP2\n- 使用服务端渲染\n  \n  客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\n  服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\n\n- 静态资源使用 CDN\n- 将 CSS 放在文件头部，JavaScript 文件放在底部\n- 使用字体图标 iconfont 代替图片图标\n- 善用缓存，不重复加载相同的资源\n- 压缩文件（js，css，图片）\n- 图片优化（懒加载，base64）\n- 分chunk，大的库考虑用CDN（react，router等）\n- 使用事件委托\n- if-else 对比 switch\n  \n  当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\n- 使用 Web Workers\n- 降低 CSS 选择器的复杂性（勿嵌套多层）\n\n## 13. 什么是防抖和节流，应用场景是啥\n    \n### 都是用于限制函数被频繁调用\n\n**防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**\n\n场景：有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n**节流：任务频繁触发的情况下，指定时间间隔内只会执行一次任务。**\n\n场景：懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取；双十一抢商品\n\n## 14. 实现链式调用\n    \n链式调用的核心就在于调用完的方法将自身实例返回\n\n``` javascript\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n    \n## 15. 继承\n    \n**原型链继承**\n\n``` javascript\nfunction Animal() {\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getColor = function() {\n    return this.colors\n}\nfunction Dog() {}\nDog.prototype =  new Animal()\n\nlet dog1 = new Dog()\ndog1.colors.push('brown')\nlet dog2 = new Dog()\nconsole.log(dog2.colors)  // ['black', 'white', 'brown']\n```\n\n**问题**\n\n- 原型中的属性会被共享\n- 实例化时无法给父类构造函数传参\n  \n**借用构造函数实现继承**\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.getName = function() {\n        return this.name\n    }\n}\nfunction Dog(name) {\n    Animal.call(this, name)\n}\n```\n借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以**会导致每次创建子类实例都会创建一遍方法**。\n\n**组合继承**\n\n组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getName = function() {\n    return this.name\n}\nfunction Dog(name, age) {\n    Animal.call(this, name)\n    this.age = age\n}\nDog.prototype =  new Animal()\nDog.prototype.constructor = Dog\n\nlet dog1 = new Dog('奶昔', 2)\ndog1.colors.push('brown')\nlet dog2 = new Dog('哈赤', 1)\nconsole.log(dog2) // { name: \"哈赤\", colors: [\"black\", \"white\"], age: 1 }\n```\n\n## 16. js中的堆栈\n    \n### 栈数据结构\n\n- 栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。\n- 栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。\n\n### 堆数据结构\n\n- 堆是一种经过排序的树形数据结构，每个结点都有一个值。\n- 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。\n\n### 变量类型与内存的关系\n\n#### 基本数据类型\n\nSting、Number、Boolean、null、undefined、Symbol\n\n- 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。\n- 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址\n\n\n## 17. Proxy的理解\n\n### 回答要点\n- Proxy的作用（拦截读取，写入等操作，可以覆盖原生操作）\n- Proxy和Object.defineProperty的区别（优势，Vue3用Proxy取代2版的defineProperty）\n- Reflect的用法（了解）\n\n### 链接\n[Proxy 和 Reflect](https://juejin.cn/post/6844904090116292616)\n\n## 18. Generator详解\n\n- 可控制的异步流程\n- async是Generator的实现（语法糖）\n\n## 19. 搞懂prototype和 __proto__\n\n### javascript继承的本质\n\n一个对象 A的__proto__属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链。\n\n### new 操作到底做了什么\n\n## 20. script标签中defer和async的区别\n\n都是异步加载 script 脚本\n- 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。\n- 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。\n\n## 21. CommonJs和Es Module的区别\n\n### CommonJs\n\n- CommonJs可以动态加载语句，代码发生在运行时\n- CommonJs导出值是拷贝，可以修改导出的值\n\n### Es Module\n\n- Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时\n- Es Module混合导出，单个导出，默认导出，完全互不影响\n- Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改\n\n### 题外话\n\nwebpack treeshaking 是基于静态检查，所以尽量使用 Es Module。\n\n\n\n\n"}},"__N_SSG":true}