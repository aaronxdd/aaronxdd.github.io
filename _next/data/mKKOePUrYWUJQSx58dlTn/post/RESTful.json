{"pageProps":{"frontmatter":{"title":"RESTful资源命名规范","date":"June 8, 2021","description":"资源路径如何正确的定义？应该遵守怎样的命名规范？"},"post":{"content":"\n在 **REST** 中，主要的数据描述称为 **Resource**，拥有明确一致的 **REST** 命名规范，长期来看将是最好的决策\n\n> 资源可以是单例或者集合，比如说，customers是一个集合资源，customer是一个单个资源。我们在URI中可以用\"/customers\"来定义集合资源，用\"/customers/{customerId}\"来定义单个资源。\n\n> 一个资源也可以包含子集合资源，比如说，一个顾客他名下有多个account，我们可以这样\"/customers/{customerId}/accounts\"表示。相同的，单独表示某个顾客的某个账号，我们可以这样\"/customers/{customerId}/accounts/{accountId}\"。\n\n## Tips\n1. 使用名词表示资源（而不是动词）\n\n\n2. 使用\"/\"表示层次关系\n\n```url\nhttp://api.example.com/customers/{customerId}/accounts/{accountId}\n```\n\n\n3. 结尾不需要加\"/\"\n\n```url\nhttp://api.example.com/device-management/managed-devices/\n\n//better\nhttp://api.example.com/device-management/managed-devices\n```\n\n4. 用\"-\"代替驼峰的命名方式，提高可读性,\n   也不要使用下划线\"_\"（某些字体下会显示不明显，或者被遮盖）\n\n```url\nhttp://api.example.com/inventoryManagement/managedEntities/{id}/installScriptLocation \n\nhttp://api.example.com/inventory_management/managed_entities/{id}/install_script_location\n\n//better\nhttp://api.example.com/inventory-management/managed-entities/{id}/install-script-location\n```\n\n5. 使用小写字母\n\n\n6. 不要加文件后缀\n\n```url\nhttp://api.example.com/device-management/managed-devices.xml  /*Do not use it*/\n\nhttp://api.example.com/device-management/managed-devices \t/*This is correct URI*/\n```\n\n7. 不要使用CRUD的一些方法名词（例如：getXXX，deletXXX，与第一点类似）\n\n```url\nHTTP GET http://api.example.com/device-management/managed-devices  //Get all devices\nHTTP POST http://api.example.com/device-management/managed-devices  //Create new Device\n\nHTTP GET http://api.example.com/device-management/managed-devices/{id}  //Get device for given Id\nHTTP PUT http://api.example.com/device-management/managed-devices/{id}  //Update device for given Id\nHTTP DELETE http://api.example.com/device-management/managed-devices/{id}  //Delete device for given Id\n```\n\n\n8. 用query形式来过滤资源集合（区别于params形式，理解）\n```url\nhttp://api.example.com/device-management/managed-devices\n\nhttp://api.example.com/device-management/managed-devices?region=USA\nhttp://api.example.com/device-management/managed-devices?region=USA&brand=XYZ\nhttp://api.example.com/device-management/managed-devices?region=USA&brand=XYZ&sort=installation-date\n```\n\n\n## 参考：\n- [resource-naming](https://restfulapi.net/resource-naming)\n","excerpt":""},"previousPost":{"slug":"sass-summary","frontmatter":{"title":"Sass总结篇","date":"June 7, 2021","description":"Sass的常用功能总结"},"excerpt":"","content":"\n以前只用过嵌套和变量，所以在脑子里CSS预处理器就这点功能。\n\n最近准备看下Sass文档，学习和总结下，看了中文文档有些翻译确实让人看不太懂，所以决定对着英文文档自己啃。\n\n本准备像上一篇一样，把英文文档逐篇翻译，后来想想算了，所以总结了Sass常用的一些功能点。\n\n## 变量\n\n变量以 **$** 开头，非驼峰写法，以 **-** 做命名切割\n\n![sass-variable](sass-variable.jpeg)\n\n⚠️**注意**：原生CSS也是带有变量功能的，命名以 **--** 开头，点击[这里](https://sass-lang.com/documentation/variables)查看具体的区别\n\n\n## 嵌套\n\n原生CSS是不支持嵌套写法的，但有个相关的[草案](https://drafts.csswg.org/css-nesting-1)，相信不久的将来也会支持\n\n![sass-css-nesting](sass-css-nesting.jpeg)\n\n用Sass我们可以这样写\n\n![sass-css-nesting](sass-nesting.jpeg)\n\n嵌套写法也是我们大部分人最常用的功能，没有之一。。。\n\n⚠️**注意**：嵌套是很有用，但也是很容易滥用的地方，一般建议嵌套不超过三层，否则会影响性能，在Sass中还提供了一个[@at-root](https://sass-lang.com/documentation/at-rules/at-root) 的功能，可以让你直接跳出去。这样也可以避免嵌套层级过深。\n\n\n## 父选择器（&）\n\n在嵌套中，我们用 **&** 来表示当前位置的父类节点，通常在写伪类的时候会用到\n\n![sass-&](sass-&.jpeg)\n\n## 占位符选择器（placeholder）\n\n占位符选择器以 **%** 开头，通过 **@extend** 来应用\n\n![sass-placeholder](sass-placeholder.jpeg)\n\n编译出来的CSS代码中并不会包括 **%placeholder** 规则中的样式，除非是通过 **@extend** 对其进行调用\n\n它和 **mixin** 的使用也很像，但是还是有区别\n\n### mixin\n\n![sass-placeholder-mixin](sass-placeholder-mixin.jpeg)\n\n### placeholder\n\n![sass-placeholder1](sass-placeholder1.jpeg)\n\n## 继承（@extend）\n\n所谓 **@extend** 用法就是你为通用样式写一个 **.** 样式类，然后要用到改样式的地方再 **@extend**\n\n![sass-extend](sass-extend.jpeg)\n\n我们可以从上图中很直接的看出它与 **%placeholder** 的区别\n\n还有一个问题，**.icon** 类我们在 **Html** 中不会用到，因为它仅仅是用来被 **@extend** 的，我们可以使用 **%placeholder** 来解决这种现象\n\n## mixin\n\n**mixin** 前面介绍占位符的时候也稍待介绍下，它主要用来修饰 **function** ，可以传入参数，也可以给参数设置个默认值\n\n![sass-mixin](sass-mixin.jpeg)\n\n## SassScript相关\n\n### @if和@else\n\n流程控制指令一般会配合 **mixin** 一起使用\n\n![sass-if-else](sass-if-else.jpeg)\n\n### @for\n\n![sass-for](sass-for.jpeg)\n\n\n### @while\n\n![sass-while](sass-while.jpeg)\n\n\n## 参考\n- [掌握sass这些技能，帮助提升开发效率](https://juejin.cn/post/6870009638478151688)\n- [your-nesting-is-harmful](https://medium.com/@verpixelt/your-nesting-is-harmful-a1ffddaf7e43)\n- [your-placeholder-selectors](https://sass-lang.com/documentation/style-rules/placeholder-selectors)\n\n\n\n"},"nextPost":{"slug":"createStore","frontmatter":{"title":"redux源码系列之createStore","date":"June 23, 2021","description":"深入源码解析createStore内部代码"},"excerpt":"","content":"\n``` javascript\nconst store = createStore(reducer, [initState, enhancer])\n```\n\n## 参数\n\n1. [**reducer**](https://redux.js.org/understanding/thinking-in-redux/glossary#reducer) (*Function*):  接受两个参数，分别是当前的 **state** 和要处理的 [**action**](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow#actions)\n\n2. [**preloadedState**] (*any*):  初始状态的 **state**，其实在实际开发中很少在这边给应用赋上初始 **state**，一般会在各自的 **reducer** 中赋上初始 **state**: \n\n``` javascript\nconst initialState = {}\n\n  // reducer\nconst todoApp = (state = initialState, action) => {\n  // 这里暂不处理任何 action，\n  // 仅返回传入的 state。\n  return state\n}\n```\n值得注意的是: 通常情况下，通过 **preloadedState** 指定的 **state** 要优先于通过 **reducer** 指定 **state** : \n\n``` javascript\nimport { createStore } from 'redux';\n// reducer\nconst a = (state = 'lol', action) => {\n  return state;\n}\n\nconst b = (state = 'wat', action) => {\n  return state;\n}\n\n// const combined = combineReducers({ a, b })\nconst combined = (state = {}, action) => {\n  return {\n    a: a(state.a, action),\n    b: b(state.b, action)\n  };\n}\n\nconst store = createStore(combined, { a: 'horse' });\nconsole.log(store.getState()); // { a: 'horse', b: 'wat' }\n```\n\n3. [**enhancer**] (*Function*):  高阶函数，通常是指中间件，必须用 **applyMiddleware()** 包装下：\n\n``` javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\n\nfunction logger({ getState }) {\n  return next => action => {\n    console.log('will dispatch', action)\n\n    // Call the next dispatch method in the middleware chain.\n    const returnValue = next(action)\n\n    console.log('state after dispatch', getState())\n\n    // This will likely be the action itself, unless\n    // a middleware further in chain changed it.\n    return returnValue\n  }\n}\n\nconst store = createStore(todos, applyMiddleware(thunk, logger))\n```\n\n## 返回值\n[**store**](https://redux.js.org/api/store): 是一个对象，包含了一些方法（[**dispatch**](https://redux.js.org/api/store#dispatchaction)，[**getState**](https://redux.js.org/api/store#getstate)等)，保存了应用所有 **state** 的对象。改变 **state** 的惟一方法是 **dispatch action**。\n\n``` typescript\nconst store = {\n  dispatch: dispatch as Dispatch<A>,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable\n} as unknown as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\nreturn store\n```\n\n## 代码结构\n便于理解，我们忽略函数中 **TS** 的一些类型定义，大致结构如下：\n\n``` javascript\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 传入参数的判断\n  // ...\n\n  // 参数中enhancer function存在，一般是指applyMiddleware()\n  if (typeof enhancer !== \"undefined\" && typeof enhancer === \"function\") {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  let currentReducer = reducer; // 当前store中的reducer\n  let currentState = preloadedState; // 当前store中存储的状态\n  let currentListeners = []; // 当前store中放置的监听函数\n  let nextListeners = currentListeners; // 下一次dispatch时的监听函数\n  let isDispatching = false; // 用于判断是否正在dispatch\n\n  // 获取state\n  function getState() {\n    //...\n  }\n\n  // 添加一个监听函数，每当dispatch被调用的时候都会执行这个监听函数\n  function subscribe() {\n    //...\n  }\n\n  // 触发了一个action，因此我们调用reducer，得到的新的state，并且执行所有添加到store中的监听函数。\n  function dispatch() {\n    //...\n  }\n\n  // 忽略两个不常用的方法replaceReducer，observable...\n\n  // createStore的时候会执行一次INIT action的dispatch\n  // 便于其他reducer获取初始值\n  dispatch({ type: ActionTypes.INIT } as A);\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    //下面两个是主要面向库开发者的方法，暂时先忽略\n    //replaceReducer,\n    //observable\n  };\n}\n```\n\n可以看出，**createStore** 方法创建了一个 **store**，但是并没有直接将这个 **store** 的状态 **state** 返回，而是返回了一系列方法，外部可以通过这些方法（**getState**）获取 **state**，或者间接地（通过调用 **dispatch** ）改变 **state**。\n\n下面我们来看下各个方法的具体实现\n\n### getState\n\n``` typescript\nfunction getState(): S {\n  // 如果正在dispath会抛出异常\n  if (isDispatching) {\n    throw new Error(\n      'You may not call store.getState() while the reducer is executing. ' +\n        'The reducer has already received the state as an argument. ' +\n        'Pass it down from the top reducer instead of reading it from the store.'\n    )\n  }\n\n  return currentState as S\n}\n```\n\n很简单，就是获取当前 **state**，我们可以通过 ``` store.getState() = ... ``` 来修改 **state**，但是一般来说，redux不建议这样做，只能通过 **dispatch action** 来修改 **state**。\n\n### subscribe\n\n``` typescript\n  // 若相等，做一下currentListeners浅拷贝\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  function subscribe(listener: () => void) {\n    if (typeof listener !== 'function') {\n      // throw Error\n    }\n    if (isDispatching) {\n      // throw Error\n    }\n    //设置一个标志，标志该监听器已经订阅了\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    // push到nextListeners数组中，下次dispatch会调用\n    nextListeners.push(listener)\n\n    // 返回了一个取消订阅的函数，即从数组中删除该监听函数\n    return function unsubscribe() {\n      // 如果已经取消订阅过了，直接返回\n      if (!isSubscribed) {\n        return\n      }\n      if (isDispatching) {\n        // throw Error\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      // 从下一轮的监听函数数组（用于下一次dispatch）中删除这个监听器。\n      const index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n      // 清空当前currentListeners\n      currentListeners = null\n    }\n  }\n```\n\n### dispatch\n\n``` typescript\nfunction dispatch(action: A) {\n  if (!isPlainObject(action)) {\n    // throw Error\n  }\n\n  if (typeof action.type === 'undefined') {\n    // throw Error\n  }\n\n  if (isDispatching) {\n    // throw Error\n  }\n\n  try {\n    // 标记正在dispatch\n    isDispatching = true\n    // 调用reducer，得到新state\n    currentState = currentReducer(currentState, action)\n  } finally {\n    isDispatching = false\n  }\n\n  const listeners = (currentListeners = nextListeners)\n  // 遍历执行监听数组中的所有监听函数\n  for (let i = 0; i < listeners.length; i++) {\n    const listener = listeners[i]\n    listener()\n  }\n\n  // 返回传入的action\n  return action\n}\n```\n\n**dispatch** 是修改 **state** 的唯一途径（**redux** 规定）。\n\n## 总结\n整个 **createStore** function 还是比较容易理解的，记住应用中应有且仅有一个 store。\n\n## 参考\n- [Redux createStore API](https://redux.js.org/api/createstore)\n- [Redux createStore API（中文版）](https://www.redux.org.cn/docs/api/createStore.html)\n"}},"__N_SSG":true}