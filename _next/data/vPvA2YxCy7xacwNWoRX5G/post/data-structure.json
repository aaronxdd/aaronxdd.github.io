{"pageProps":{"frontmatter":{"title":"数据结构笔记","date":"June 30, 2021","description":null},"post":{"content":"\n## 存储方式\n\n### 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）\n\n散列表、栈、队列、堆、树、图等等各种数据结构都属于上层建筑，而数组和链表才是「结构基础」。\n\n### 两者优缺点\n\n**数组**\n\n1. 由于是连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间，访问数组元素的时间复杂度 O(1)；\n2. 但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。\n\n**链表**\n\n1. 因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；\n2. 如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。\n3. 但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。\n\n\n## 基本操作\n\n数据结构的基本操作无非遍历 + 访问，即增删改查；\n\n但是不同数据结构的增删改查的效率是不一样的，所以我们需要了解各数据结构的特性以便我们在不同场景下提高代码的性能。\n\n遍历 + 访问 分为两种形式：线性的和非线性的。\n\n线性：以for/while 迭代为代表\n\n非线性：以递归为代表\n\n\n","excerpt":""},"previousPost":{"slug":"applyMiddleware","frontmatter":{"title":"redux源码系列之applyMiddleware","date":"June 28, 2021","description":null},"excerpt":"","content":"\n终于来到 **applyMiddleware** 部分，理解了 [**compose**](https://xudongdong.site/post/compose) 和 [**Currying**](https://xudongdong.site/post/currying)，这部分源码也变得很好理解\n\n这个方法是用来应用中间件的，用过 **node** 的同学应该比较了解，中间件我的理解类似于插件，一般为了避免系统框架过于臃肿，我们把常用的功能剥离开来，以中间件的形式插入到框架中来实现复杂的应用处理\n\n我们首先看下 **applyMiddleware** 的用法\n\n``` js\nimport { applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\nconst store = createStore(reducer, applyMiddleware(thunk, logger))\n```\n\n**createStore** 内部的调用\n\n``` js\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 传入参数的判断\n  // ...\n\n  // 参数中enhancer function存在，一般是指applyMiddleware()\n  if (typeof enhancer !== \"undefined\" && typeof enhancer === \"function\") {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  // 省略\n}\n```\n\n由此可以得出 **applyMiddleware** 的 **API** 调用\n\n``` js\napplyMiddleware(thunk, logger)(createStore)(reducer, preloadedState);\n\n// applyMiddleware(...middlewares)(createStore)(reducer, preloadedState);\n```\n\n结合源码\n\n我们将源码中 **TS** 部分去除，得出函数主体代码\n\n``` javascript\nimport { compose } from \"./compose\";\n\nfunction applyMiddleware(...middlewares) {\n  // use Currying function\n  return (createStore) => (reducer, preloadedState) => {\n    // 获取store\n    const store = createStore(reducer, preloadedState);\n    // 初始化dispatch\n    let dispatch = () => {\n      // 在dispatch完成正在赋值之前，调用会报错\n      throw new Error(\"目前还不能使用dispatch\")\n    }\n\n    // 给每个中间件的默认传参：getState，dispatch\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    \n    // 加入默认参数后的中间件chain\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 对chain做compose操作，并赋值给dispatch\n    dispatch = compose(...chain)(store.dispatch)\n  }\n\n  // 返回store的属性和dispatch\n  return {\n    ...store,\n    dispatch\n  }\n}\n```\n\n主要难以理解的部分还是 **compose** 这一块\n\n我们拿两个中间件做解析\n\n``` javascript\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\napplyMiddleware(thunk, logger)(createStore)(reducer, preloadedState);\n\n// applyMiddleware chain部分\nconst middlewareAPI = { getState, dispatch }\n\nconst chain = [thunk, logger].map(middleware => middleware(middlewareAPI))\n// const chain = [thunk(middlewareAPI), logger(middlewareAPI)]\n// const chain = [thunk({ getState, dispatch }), logger({ getState, dispatch })]\n\n// applyMiddleware compose dispatch部分\ndispatch = compose(...chain)(store.dispatch)\n// dispatch = compose(thunk({ getState, dispatch }), logger({ getState, dispatch }))(store.dispatch)\n\n// 根据 compose 代码可转化为\n// dispatch = thunk({ getState, dispatch })(logger({ getState, dispatch })(store.dispatch))\n```\n\n代码到这边我们需要结合 **redux-thunk** 源码继续解析了\n\n``` js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n\n把\n``` js\ndispatch = thunk({ getState, dispatch })(logger({ getState, dispatch })(store.dispatch))\n```\n\n放到 **thunk** 中\n\n``` js\ndispatch = ({ getState, dispatch }) => {\n  return ({ getState, dispatch }) => (logger({ getState, dispatch })(store.dispatch)) => (action) => {\n\n    // 如果有异步action，会先执行异步action，在执行传进来的logger function\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return logger({ getState, dispatch })(store.dispatch)(action);\n  }\n}\n```\n\n应用了 **thunk** 和 **logger** 的 **redux** 应用，会先执行异步 **action**，在执行 **logger** 中间件。\n\n从代码上看，**applyMiddleware** 最主要的作用就是对原始的 **dispatch** 方法进行了重新赋值，并将它与 **store** 的属性返回。\n\n\n## 参考\n- [redux-thunk](https://github.com/reduxjs/redux-thunk/blob/master/src/index.js)\n\n"},"nextPost":{"slug":"http","frontmatter":{"title":"面试题集合（网络篇）","date":"July 1, 2021","description":null},"excerpt":"","content":"\n## 1. TCP/IP 四层网络模型\n\n第一层：应用层，主要有负责web浏览器的 **HTTP** 协议， 文件传输的 **FTP** 协议，负责电子邮件的 **SMTP** 协议，负责域名系统的 **DNS** 等。\n\n第二层：传输层，主要是有可靠传输的 **TCP** 协议，特别高效的 **UDP** 协议。主要负责传输应用层的数据包。\n\n第三层：网络层，主要是 **IP** 协议。主要负责寻址（找到目标设备的位置）\n\n第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。\n\n## 2. 用户输入url到页面展示的过程\n   \n- DNS解析\n  \n  域名到真实IP的寻址过程\n- 发起TCP连接\n  \n  三次握手🤝，确定 **client** ，**server** 双端的接受发送能力\n- 发起Http请求\n- 服务器处理请求并返回HTTP报文\n- 浏览器解析渲染页面\n\n## 3. 说一下 Http 缓存策略，有什么区别，分别解决了什么问题\n   \n   浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。\n\n  - 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\n  - 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified通过请求 发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\n\n  HTTP缓存都是从第二次请求开始的：\n\n  - 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\n  - 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：\n  ![chrome-cache](chrome-cache.jpeg)\n\n## 4. 常见的Http状态码\n\n- 200 OK：表示从客户端发送给服务器的请求被正常处理并返回\n- 204 No Content：表示客户端发送给服务端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）\n- 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL\n- 302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL\n- 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码\n- 400 Bad Request：表示请求报文中存在语法错误（一般指参数）\n- 401 Unauthorized：没有经过身份认证，需要通过HTTP认证\n- 403 Forbidden：身份认证过了，但是没有权限\n- 404 Not Found：(客户端问题)请求的资源没有找到，说明客户端错误的请求了不存在的资源\n- 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时\n- 503 Server Unavailable：服务不可用，一般指维护中或者服务重启中\n\n## 5. 跨域的复杂请求和简单请求的区别\n\n### 简单请求\n\n- HTTP方法是下列之一（HEAD、GET、POST）\n- HTTP头信息不超出以下几种字段\n  \n  **Accept**\n\n  **Accept-Language**\n\n  **Content-Type** （application/x-www-form-urlencoded、multipart/form-data、text/plain）\n\n任何一个 **不满足上述要求** 的请求，即被认为是复杂请求\n\n### 复杂请求\n\n- 一个复杂请求不仅有：包含通信内容的请求，同时也包含预请求。\n\n- 复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种\"预请求\"，此时作为服务端，也需要返回\"预回应\"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。\n\n## 5. TCP和UDP\n\n- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。\n- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为\n- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP\n- HTTP3.0取两者之长\n"}},"__N_SSG":true}