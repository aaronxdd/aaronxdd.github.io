<!DOCTYPE html><html lang="en-US"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if("system"===e||(!e&&true)){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else if(e) d.add(e)}catch(e){}}()</script><title>面试题集合（HTML篇） | Xu dongdong&#x27;s blog</title><meta name="description" content="A blog created with Next.js and Tailwind.css"/><meta property="og:type" content="website"/><meta name="og:title" property="og:title" content="面试题集合（HTML篇）"/><meta name="og:description" property="og:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="面试题集合（HTML篇）"/><meta name="twitter:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:creator" content="https://twitter.com/WhyYouJames"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/f8d73a71d7937abe53e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8d73a71d7937abe53e1.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c6f966696d7d46f48c33.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" as="script"/><link rel="preload" href="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bslug%5D-48f028bae094661c2f5e.js" as="script"/></head><body><div id="__next"><div class="w-full min-h-screen dark:bg-gray-700 dark:text-white flex"><div class="max-w-screen-md px-4 py-12 mx-auto antialiased font-body flex flex-col flex-grow"><header class="flex items-center justify-between  mb-2"><div class="max-w-lg"><h1><a class="text-2xl font-black text-black no-underline font-display dark:text-white" href="/">Xu dongdong&#x27;s blog</a></h1></div></header><main class="flex-grow"><article><header class="mb-8"><h1 class="mb-2 text-6xl font-black leading-none font-display">面试题集合（HTML篇）</h1></header><div class="mb-4 prose lg:prose-lg dark:prose-dark"><h2>1. 对HTML语义化的一些理解</h2><ul><li>标签语义化有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取。SEO</li><li>有利于构建清晰的机构，有利于团队的开发、维护。</li></ul><h2>2. 讲讲HTML5加了哪些东西</h2><ul><li>语义化标签（header，footer等）</li><li>audio，video</li><li>Canvas</li><li>本地存储，各种storage</li><li>Web Worker多线程</li></ul><h2>3. 那些你不知道的meta标签</h2><ul><li><p>name 属性</p><p>用于描述页面信息（内容，关键词，作者等）</p><ul><li>author</li><li>description</li><li>keywords</li><li>viewport</li></ul></li><li><p>http-equiv</p><p>用于描述HTTP头部</p><ul><li>content-type</li><li>content-security-policy（内容策略）</li></ul></li></ul></div><hr class="mt-4"/><footer><div class="flex items-center mt-8 mb-16"><picture class="flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow"><source type="image/webp" data-srcset="/_next/static/images/profile-8ed88833980dc158e6d9ec3b1bb7c0a8.png.webp"/><source type="image/png" data-srcset="/_next/static/images/profile-44443f720aaa2ff4c2b67336ff9f586b.png"/><img class="lazyload blur flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow" alt="Profile" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAAFBSURBVAXBSS8DYQCA4fcz33RqWpUuU8tEkKjtUqIhJELiRCJxcfRf/AknP8OFiwMXF40DSVO0iRhLVbR0mX08jzg63Ikc28NzA1QR8vBcJ6Eq9AYUDMNAxlOsrBSRH40WIoLJbIL1qTzS63JvfRKJECd0MM0h9IREmZ4YOyaAw7UCG6UlNpfneaw8UbNa4Ie4tk9uSEO6nouCoO9FZEZNWu8WcUViZpLsH+wyMjnBX7eDzCuQ0zVsAtpvb1RrL9Stb3RNkO//MSwl6mAcWRrNMLO1jZ5UuSiXITXO6vISp+eXbNs+olal02kj/YUidiyJ5wsK63u8N74xSxmmyrecnF2TNtJoUkUa2RxO95ew3+al1yXm9tCCiLnCLPqrRbP5QSRC5GLsi0DVkekUj5UKjZ8+TSdA6ikWigYDqs/VzR3/TEV/Airrby8AAAAASUVORK5CYII="/></picture><p class="text-base leading-7 font-semibold">不正经的人机交互工程师</p></div></footer></article><nav class="flex flex-wrap justify-between mb-10"><a class="text-lg font-bold" href="/post/js">← <!-- -->面试题集合（JS篇）</a><a class="text-lg font-bold" href="/post/easy">算法题（简单系列）<!-- --> →</a></nav></main><footer class="text-lg font-light mt-3">© <!-- -->2021<!-- --> <!-- -->Built with<!-- --> <a href="https://nextjs.org/">Next.js</a>🔥, Deployed on<!-- --> <a href="https://pages.github.com/">GitHub Pages</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"面试题集合（HTML篇）","date":"July 17, 2021","description":null},"post":{"content":"\n## 1. 对HTML语义化的一些理解\n\n- 标签语义化有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取。SEO\n- 有利于构建清晰的机构，有利于团队的开发、维护。\n\n## 2. 讲讲HTML5加了哪些东西\n\n- 语义化标签（header，footer等）\n- audio，video\n- Canvas\n- 本地存储，各种storage\n- Web Worker多线程\n\n## 3. 那些你不知道的meta标签\n\n- name 属性\n  \n  用于描述页面信息（内容，关键词，作者等）\n  - author\n  - description\n  - keywords\n  - viewport\n\n- http-equiv\n  \n  用于描述HTTP头部\n\n  - content-type\n  - content-security-policy（内容策略）","excerpt":""},"previousPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"July 17, 2021","description":null},"excerpt":"","content":"\n## 1. infinity代表什么数据\n\n  在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n## 2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n## 3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\n- new String(\"A\") :\n  \n  返回类型：引用类型，堆内存存储\n  返回值：字符串对象\n\n- String(\"A”) ：\n  \n  返回类型：基本类型，栈内存存储\n  返回值：字符串值\n\n## 4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr =\u003e arr.reduce((a, b) =\u003e a + b)\n```\n\n## 5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n## 6. 图片懒加载原理\n   \n  图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n``` js\nlet imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\n// 修正错误，需要加上自执行\n- const imgLazyLoad = function() {\n+ const imgLazyLoad = (function() {\n    let count = 0\n    \n   return function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) =\u003e {\n            let rect = img.getBoundingClientRect()\n            if (rect.top \u003c window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) =\u003e !deleteIndexList.includes(index))\n   }\n- }\n+ })()\n\n// 这里最好加上节流处理\ndocument.addEventListener('scroll', imgLazyLoad)\n\n```\n\n## 7. 懒加载和预加载\n\n  两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n## 8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n## 9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' \u0026\u0026 /native code/.test(f.toString())\n}\n```\n\n## 10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n  js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n## 11. 函数的方法 call()、apply()、bind()的区别\n\n### 改变函数执行上下文，也就是改变this的指向\n\n- call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。\n- call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n\n## 12. 前端性能优化\n- 减少 HTTP 请求\n- 使用 HTTP2\n- 使用服务端渲染\n  \n  客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\n  服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\n\n- 静态资源使用 CDN\n- 将 CSS 放在文件头部，JavaScript 文件放在底部\n- 使用字体图标 iconfont 代替图片图标\n- 善用缓存，不重复加载相同的资源\n- 压缩文件（js，css，图片）\n- 图片优化（懒加载，base64）\n- 分chunk，大的库考虑用CDN（react，router等）\n- 使用事件委托\n- if-else 对比 switch\n  \n  当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\n- 使用 Web Workers\n- 降低 CSS 选择器的复杂性（勿嵌套多层）\n\n## 13. 什么是防抖和节流，应用场景是啥\n    \n### 都是用于限制函数被频繁调用\n\n**防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**\n\n场景：有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n**节流：任务频繁触发的情况下，指定时间间隔内只会执行一次任务。**\n\n场景：懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取；双十一抢商品\n\n## 14. 实现链式调用\n    \n链式调用的核心就在于调用完的方法将自身实例返回\n\n``` javascript\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n    \n## 15. 继承\n    \n**原型链继承**\n\n``` javascript\nfunction Animal() {\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getColor = function() {\n    return this.colors\n}\nfunction Dog() {}\nDog.prototype =  new Animal()\n\nlet dog1 = new Dog()\ndog1.colors.push('brown')\nlet dog2 = new Dog()\nconsole.log(dog2.colors)  // ['black', 'white', 'brown']\n```\n\n**问题**\n\n- 原型中的属性会被共享\n- 实例化时无法给父类构造函数传参\n  \n**借用构造函数实现继承**\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.getName = function() {\n        return this.name\n    }\n}\nfunction Dog(name) {\n    Animal.call(this, name)\n}\n```\n借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以**会导致每次创建子类实例都会创建一遍方法**。\n\n**组合继承**\n\n组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getName = function() {\n    return this.name\n}\nfunction Dog(name, age) {\n    Animal.call(this, name)\n    this.age = age\n}\nDog.prototype =  new Animal()\nDog.prototype.constructor = Dog\n\nlet dog1 = new Dog('奶昔', 2)\ndog1.colors.push('brown')\nlet dog2 = new Dog('哈赤', 1)\nconsole.log(dog2) // { name: \"哈赤\", colors: [\"black\", \"white\"], age: 1 }\n```\n\n## 16. js中的堆栈\n    \n### 栈数据结构\n\n- 栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。\n- 栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。\n\n### 堆数据结构\n\n- 堆是一种经过排序的树形数据结构，每个结点都有一个值。\n- 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。\n\n### 变量类型与内存的关系\n\n#### 基本数据类型\n\nSting、Number、Boolean、null、undefined、Symbol\n\n- 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。\n- 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址\n\n\n## 17. Proxy的理解\n\n### 回答要点\n- Proxy的作用（拦截读取，写入等操作，可以覆盖原生操作）\n- Proxy和Object.defineProperty的区别（优势，Vue3用Proxy取代2版的defineProperty）\n- Reflect的用法（了解）\n\n### 链接\n[Proxy 和 Reflect](https://juejin.cn/post/6844904090116292616)\n\n## 18. Generator详解\n\n- 可控制的异步流程\n- async是Generator的实现（语法糖）\n\n## 19. 搞懂prototype和 __proto__\n\n### javascript继承的本质\n\n一个对象 A的__proto__属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链。\n\n### new 操作到底做了什么\n\n## 20. script标签中defer和async的区别\n\n都是异步加载 script 脚本\n- 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。\n- 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。\n\n## 21. CommonJs和Es Module的区别\n\n### CommonJs\n\n- CommonJs可以动态加载语句，代码发生在运行时\n- CommonJs导出值是拷贝，可以修改导出的值\n\n### Es Module\n\n- Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时\n- Es Module混合导出，单个导出，默认导出，完全互不影响\n- Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改\n\n### 题外话\n\nwebpack treeshaking 是基于静态检查，所以尽量使用 Es Module。\n\n\n## 22. getSnapshotBeforeUpdate\n\n## 23. target和currentTarget\n\n## 24. 常用的hooks\n\n"},"nextPost":{"slug":"easy","frontmatter":{"title":"算法题（简单系列）","date":"July 25, 2021","description":null},"excerpt":"","content":"\n## 1. 两数之和\n\n### 题目描述\n\n给定一个整数数组 **nums** 和一个目标值 **target**，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n### 示例\n\n``` javascript\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n````\n\n### 代码实现\n\n``` javascript\nconst findTotal = (nums, target) =\u003e {\n  for(let i = 0; i \u003c nums.length; i++) {\n    if (nums.includes(target-nums[i])) {\n      return [i, nums.indexOf(target-nums[i])];\n    }\n  }\n}\n```\n\n``` javascript\nconst twoSum = (nums, target) =\u003e {\n  let preNums = {};\n  for (let i = 0; i \u003c nums.length; i++) {\n    const targetNum = target - nums[i];\n    if (preNums[targetNum]) {\n      return [preNums[targetNum], i];\n    }\n    preNums[nums[i]] = i;\n  }\n}\n```\n\n\n## 2. 整数反转\n\n### 题目描述\n\n![reverse-integer](reverse-integer.jpeg)\n\n\n### 代码实现\n\n``` javascript\nconst reverse = (x) =\u003e {\n  let result = 0;\n  while (x !== 0) {\n    result = result * 10 + (x % 10);\n    x = Math.floor(x / 10);\n  }\n\n  if (result \u003c -Math.pow(2, 31) || result \u003e Math.pow(2, 31) - 1) {\n    return 0;\n  }\n  return result;\n};\n```\n\n## 3. 合并两个有序链表\n\n### 题目描述\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n### 示例1\n\n![merge-two-sorted-lists](merge-two-sorted-lists.jpeg)\n\n``` javascript\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n### 示例2\n\n``` javascript\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n### 示例3\n\n``` javascript\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n### 提示\n\n- 两个链表的节点数目范围是 [0, 50]\n- -100 \u003c= Node.val \u003c= 100\n- l1 和 l2 均按 非递减顺序 排列\n\n``` javascript\n// 例如 现有两个链表\nconst ListNode1 = {\n  value: 0,\n  next: {\n    value: 2,\n    next: {\n      value: 4,\n      next: null\n    }\n  }\n}\n\nconst ListNode2 = {\n  value: 1,\n  next: {\n    value: 3,\n    next: {\n      value: 5,\n      next: null\n    }\n  }\n}\n```\n\n### 实现\n\n``` javascript\nconst mergeTwoLists = (l1, l2) =\u003e {\n  if (l1 === null) {\n    return l2\n  }\n  if (l2 === null) {\n    return l1\n  }\n  if (l1.value \u003c l2.value) {\n    l1.next = mergeTwoLists(l1.next, l2)\n    return l1\n  }\n  if (l2.value \u003c l1.value) {\n    l2.next = mergeTwoLists(l2.next, l1)\n    return l2\n  }\n}\n```\n\n## 4. 最大子序和\n\n### 题目描述\n\n给定一个整数数组 **nums** ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n### 示例1\n\n``` javascript\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n### 示例2\n\n``` javascript\n输入：nums = [1]\n输出：1\n```\n\n### 示例3\n\n``` javascript\n输入：nums = [0]\n输出：0\n```\n\n### 示例4\n\n``` javascript\n输入：nums = [-1]\n输出：-1\n```\n\n### 示例5\n\n``` javascript\n输入：nums = [-100000]\n输出：-100000\n```\n\n### 提示\n- 1 \u003c= nums.length \u003c= 3 * 104\n- -105 \u003c= nums[i] \u003c= 105\n\n``` javascript\nconst maxSubArray = (nums) =\u003e {\n  let pre = 0;\n  let max = nums[0];\n  nums.forEach(x =\u003e {\n    pre = Math.max(pre + x, x);\n    max = Math.max(max, pre);\n  });\n  return max;\n};\n```\n\n## 5. 反转链表\n\n### 题目描述\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n### 示例:\n\n``` javascript\nconst ListNode = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: {\n          value: 5,\n          next: null\n        }\n      }\n    }\n  }\n}\n\n输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL\n输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL\n```\n\n### 限制：\n\n``` javascript\n0 \u003c= 节点个数 \u003c= 5000\n```\n\n``` javascript\nconst reverseList = (head) =\u003e {\n  let pre = null;\n  let cur = head;\n  while(cur) {\n    const next = cur.next;\n    cur.next = pre;\n    pre = cur;\n    cur = next;\n  }\n  return pre;\n}\n```\n\n## 6. 二叉树的最大深度\n\n### 题目描述\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明： 叶子节点是指没有子节点的节点。**\n\n### 示例\n\n给定二叉树 **[3,9,20,null,null,15,7]**\n\n![maximum-depth-of-binary-tree](maximum-depth-of-binary-tree.jpeg)\n\n返回它的最大深度 3 。\n\n``` javascript\nconst maxDepth = tree =\u003e {\n  if (!tree) {\n    return 0;\n  }\n  const maxLeft = maxDepth(tree.left);\n  const maxRight = maxDepth(tree.right);\n  return Math.max(maxLeft, maxRight) + 1;\n}\n```\n\n## 7. 环形链表\n\n### 题目描述\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n### 思路\n\n给遍历过的节点打记号，如果遍历过程中遇到有记号的说明已环🤓\n\n``` javascript\nconst hasCycle = head =\u003e {\n  while(head) {\n    if (head.tag) {\n      return true;\n    }\n    head.tag = true;\n    head = head.next;\n  }\n  return false;\n}\n```\n\n\n## 8. 合并二叉树\n\n### 题目描述\n\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n### 示例\n\n![merge-two-binary-trees](merge-two-binary-trees.jpeg)\n\n**注意：合并必须从两个树的根节点开始。**\n\n``` javascript\nconst mergeTrees = (t1, t2) =\u003e {\n  if (!t1 || !t2) {\n    return t1 || t2;\n  }\n  t1.value = t1.value + t2.value;\n  t1.left = mergeTrees(t1.left, t2.left);\n  t1.right = mergeTrees(t1.right, t2.right);\n  return t1;\n}\n```\n\n## 9. 有效的括号\n\n### 题目描述\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n\n### 示例 1：\n``` javascript\n输入：s = \"()\"\n输出：true\n```\n\n### 示例 2：\n``` javascript\n输入：s = \"()[]{}\"\n输出：true\n```\n\n### 示例 3：\n``` javascript\n输入：s = \"(]\"\n输出：false\n```\n\n### 示例 4：\n``` javascript\n输入：s = \"([)]\"\n输出：false\n```\n\n### 示例 5：\n``` javascript\n输入：s = \"{[]}\"\n输出：true\n```\n\n### 提示：\n\n![valid-parentheses-alert](valid-parentheses-alert.jpeg)\n\n``` javascript\nconst isValid = (str) =\u003e {\n  const { length } = str;\n  if (length % 2 !== 0) return false;\n  let arr = [];\n  for (let item of str) {\n    switch (item) {\n      case \"(\":\n      case \"{\":\n      case \"[\":\n        arr.push(item);\n        break;\n      case \")\":\n        if (arr.pop() !== \"(\") return false;\n        break;\n      case \"}\":\n        if (arr.pop() !== \"{\") return false;\n        break;\n      case \"]\":\n        if (arr.pop() !== \"[\") return false;\n        break;\n    }\n  }\n\n  return arr.length === 0\n};\n```\n\n## 10. 爬楼梯\n\n### 题目描述\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n### 示例 1：\n\n``` javascript\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n```\n\n### 示例 2：\n\n``` javascript\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n``` javascript\nconst climbStairs = (n) =\u003e {\n  if (n \u003c 1) return 0;\n  const dp = [];\n  dp[1] = 1;\n  dp[2] = 2;\n  for (let i = 0; i \u003c n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n};\n```\n\n## 11. 二叉树的中序遍历\n\n### 题目描述\n\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n### 示例 1：\n\n![binary-tree-inorder-traversal1](binary-tree-inorder-traversal1.jpeg)\n\n``` javascript\n输入：root = [1,null,2,3]\n输出：[1,3,2]\n```\n\n### 示例 2：\n\n``` javascript\n输入：root = []\n输出：[]\n```\n\n### 示例 3：\n\n``` javascript\n输入：root = [1]\n输出：[1]\n```\n\n### 示例 4：\n\n![binary-tree-inorder-traversal2](binary-tree-inorder-traversal2.jpeg)\n\n``` javascript\n输入：root = [1,null,2]\n输出：[1,2]\n```\n\n### 示例 5：\n\n![binary-tree-inorder-traversal3](binary-tree-inorder-traversal3.jpeg)\n\n``` javascript\n输入：root = [1,null,2]\n输出：[1,2]\n```\n\n### 提示：\n\n![binary-tree-inorder-traversal-alert](binary-tree-inorder-traversal-alert.jpeg)\n\n``` javascript\nconst inorderTraversal = (root) =\u003e {\n  const res = [];\n  const inorder = (root) =\u003e {\n    if (!root) return;\n    inorder(root.left);\n    res.push(root.val);\n    inorder(root.right);\n  }\n  inorder(root)\n  return res;\n};\n```\n\n## 12. 对称二叉树\n\n### 题目描述\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n![symmetric-tree](symmetric-tree.jpeg)\n\n\u003c!-- ``` javascript\n\n``` --\u003e\n\n## 13. 买卖股票的最佳时机\n\n### 题目描述\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n### 示例 1：\n\n``` javascript\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n### 示例 2：\n\n``` javascript\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n### 提示：\n\n![best-time-to-buy-and-sell-stock-alert](best-time-to-buy-and-sell-stock-alert.jpeg)\n\n\n## 14. 只出现一次的数字\n\n### 题目描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n### 说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n### 示例 1:\n\n``` javascript\n输入: [2,2,1]\n输出: 1\n```\n\n### 示例 2:\n\n``` javascript\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n``` javascript\nconst singleNumber = (nums) =\u003e {\n  let obj = {};\n  for(const num of nums) {\n    if (!obj[num]) {\n      obj[num] = true;\n    } else {\n      delete obj[num]\n    }\n  }\n  return Number(Object.keys(obj)?.[0])\n};\n```\n\n## 15. 最小栈\n\n### 题目描述\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n  - push(x) —— 将元素 x 推入栈中。\n  - pop() —— 删除栈顶的元素。\n  - top() —— 获取栈顶元素。\n  - getMin() —— 检索栈中的最小元素。\n\n### 示例:\n\n``` javascript\n  输入：\n  [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n  [[],[-2],[0],[-3],[],[],[],[]]\n\n  输出：\n  [null,null,null,null,-3,null,0,-2]\n\n  解释：\n  MinStack minStack = new MinStack();\n  minStack.push(-2);\n  minStack.push(0);\n  minStack.push(-3);\n  minStack.getMin();   --\u003e 返回 -3.\n  minStack.pop();\n  minStack.top();      --\u003e 返回 0.\n  minStack.getMin();   --\u003e 返回 -2.\n```\n\n### 提示：\n\n- pop、top 和 getMin 操作总是在 非空栈 上调用。\n\n``` javascript\nvar MinStack = function() {\n    this.x_stack = [];\n    this.min_stack = [Infinity];\n};\n\nMinStack.prototype.push = function(x) {\n    this.x_stack.push(x);\n    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));\n};\n\nMinStack.prototype.pop = function() {\n    this.x_stack.pop();\n    this.min_stack.pop();\n};\n\nMinStack.prototype.top = function() {\n    return this.x_stack[this.x_stack.length - 1];\n};\n\nMinStack.prototype.getMin = function() {\n    return this.min_stack[this.min_stack.length - 1];\n};\n```\n\n## 16. 相交链表\n\n### 题目描述\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n![intersection-of-two-linked-lists1](intersection-of-two-linked-lists1.jpeg)\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n### 示例 1：\n\n![intersection-of-two-linked-lists2](intersection-of-two-linked-lists2.jpeg)\n\n``` javascript\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n### 示例 2：\n\n![intersection-of-two-linked-lists3](intersection-of-two-linked-lists3.jpeg)\n\n``` javascript\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n### 示例 3：\n\n![intersection-of-two-linked-lists4](intersection-of-two-linked-lists4.jpeg)\n\n``` javascript\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n```\n\n### 提示：\n\n![intersection-of-two-linked-lists-alert](intersection-of-two-linked-lists-alert.jpeg)\n\n\n\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"html"},"buildId":"RdtVzs9KCNDkk5fjGofyj","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/main-c6f966696d7d46f48c33.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" async=""></script><script src="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" async=""></script><script src="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-48f028bae094661c2f5e.js" async=""></script><script src="/_next/static/RdtVzs9KCNDkk5fjGofyj/_buildManifest.js" async=""></script><script src="/_next/static/RdtVzs9KCNDkk5fjGofyj/_ssgManifest.js" async=""></script></body></html>