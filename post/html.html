<!DOCTYPE html><html lang="en-US"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if("system"===e||(!e&&true)){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else if(e) d.add(e)}catch(e){}}()</script><title>面试题集合（HTML篇） | Xu dongdong&#x27;s blog</title><meta name="description" content="A blog created with Next.js and Tailwind.css"/><meta property="og:type" content="website"/><meta name="og:title" property="og:title" content="面试题集合（HTML篇）"/><meta name="og:description" property="og:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="面试题集合（HTML篇）"/><meta name="twitter:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:creator" content="https://twitter.com/WhyYouJames"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/f8d73a71d7937abe53e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8d73a71d7937abe53e1.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c6f966696d7d46f48c33.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" as="script"/><link rel="preload" href="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" as="script"/></head><body><div id="__next"><div class="w-full min-h-screen dark:bg-gray-700 dark:text-white flex"><div class="max-w-screen-md px-4 py-12 mx-auto antialiased font-body flex flex-col flex-grow"><header class="flex items-center justify-between  mb-2"><div class="max-w-lg"><h1><a class="text-2xl font-black text-black no-underline font-display dark:text-white" href="/">Xu dongdong&#x27;s blog</a></h1></div></header><main class="flex-grow"><article><header class="mb-8"><h1 class="mb-2 text-6xl font-black leading-none font-display">面试题集合（HTML篇）</h1></header><div class="mb-4 prose lg:prose-lg dark:prose-dark"><h2>1. 对HTML语义化的一些理解</h2><ul><li>标签语义化有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取。SEO</li><li>有利于构建清晰的机构，有利于团队的开发、维护。</li></ul><h2>2. 讲讲HTML5加了哪些东西</h2><ul><li>语义化标签（header，footer等）</li><li>audio，video</li><li>Canvas</li><li>本地存储，各种storage</li><li>Web Worker多线程</li></ul><h2>3. 那些你不知道的meta标签</h2><ul><li><p>name 属性</p><p>用于描述页面信息（内容，关键词，作者等）</p><ul><li>author</li><li>description</li><li>keywords</li><li>viewport</li></ul></li><li><p>http-equiv</p><p>用于描述HTTP头部</p><ul><li>content-type</li><li>content-security-policy（内容策略）</li></ul></li></ul></div><hr class="mt-4"/><footer><div class="flex items-center mt-8 mb-16"><picture class="flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow"><source type="image/webp" data-srcset="/_next/static/images/profile-8ed88833980dc158e6d9ec3b1bb7c0a8.png.webp"/><source type="image/png" data-srcset="/_next/static/images/profile-44443f720aaa2ff4c2b67336ff9f586b.png"/><img class="lazyload blur flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow" alt="Profile" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAAFBSURBVAXBSS8DYQCA4fcz33RqWpUuU8tEkKjtUqIhJELiRCJxcfRf/AknP8OFiwMXF40DSVO0iRhLVbR0mX08jzg63Ikc28NzA1QR8vBcJ6Eq9AYUDMNAxlOsrBSRH40WIoLJbIL1qTzS63JvfRKJECd0MM0h9IREmZ4YOyaAw7UCG6UlNpfneaw8UbNa4Ie4tk9uSEO6nouCoO9FZEZNWu8WcUViZpLsH+wyMjnBX7eDzCuQ0zVsAtpvb1RrL9Stb3RNkO//MSwl6mAcWRrNMLO1jZ5UuSiXITXO6vISp+eXbNs+olal02kj/YUidiyJ5wsK63u8N74xSxmmyrecnF2TNtJoUkUa2RxO95ew3+al1yXm9tCCiLnCLPqrRbP5QSRC5GLsi0DVkekUj5UKjZ8+TSdA6ikWigYDqs/VzR3/TEV/Airrby8AAAAASUVORK5CYII="/></picture><p class="text-base leading-7 font-semibold">不正经的人机交互工程师</p></div></footer></article><nav class="flex flex-wrap justify-between mb-10"><a class="text-lg font-bold" href="/post/js">← <!-- -->面试题集合（JS篇）</a><div></div></nav></main><footer class="text-lg font-light mt-3">© <!-- -->2021<!-- --> <!-- -->Built with<!-- --> <a href="https://nextjs.org/">Next.js</a>🔥, Deployed on<!-- --> <a href="https://pages.github.com/">GitHub Pages</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"面试题集合（HTML篇）","date":"July 17, 2021","description":null},"post":{"content":"\n## 1. 对HTML语义化的一些理解\n\n- 标签语义化有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取。SEO\n- 有利于构建清晰的机构，有利于团队的开发、维护。\n\n## 2. 讲讲HTML5加了哪些东西\n\n- 语义化标签（header，footer等）\n- audio，video\n- Canvas\n- 本地存储，各种storage\n- Web Worker多线程\n\n## 3. 那些你不知道的meta标签\n\n- name 属性\n  \n  用于描述页面信息（内容，关键词，作者等）\n  - author\n  - description\n  - keywords\n  - viewport\n\n- http-equiv\n  \n  用于描述HTTP头部\n\n  - content-type\n  - content-security-policy（内容策略）","excerpt":""},"previousPost":{"slug":"js","frontmatter":{"title":"面试题集合（JS篇）","date":"July 17, 2021","description":null},"excerpt":"","content":"\n## 1. infinity代表什么数据\n\n  在JS中Infinity用于表示无穷大的数值，且不是常量，即无法明确表示它到底有多大。可以通过isFinite(val)判断当前数字是否是无穷大，函数返回true表示不是无穷大，返回false表示是无穷大。\n\n\n## 2. 如何计算动画的帧率（FPS）\n\n- 可以借助requestAnimationFrame API，requestAnimationFrame 使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。\n\n- requestAnimationFrame的回调函数执行次数通常与浏览器屏幕刷新次数相匹配，而利用这个API实现动画的原理就是回调函数内再次调用requestAnimationFrame，所以页面不断重绘时，然后检测1秒内requestAnimationFrame调用的次数，就是当前的FPS\n\n\n## 3. 请说说new String(\"A\")和String(\"A\")分别返回的结果，请解释为什么\n\n- new String(\"A\") :\n  \n  返回类型：引用类型，堆内存存储\n  返回值：字符串对象\n\n- String(\"A”) ：\n  \n  返回类型：基本类型，栈内存存储\n  返回值：字符串值\n\n## 4. 请通过reduce函数实现一维数组的求和\n\n``` javascript\nconst sum = arr =\u003e arr.reduce((a, b) =\u003e a + b)\n```\n\n## 5. 请说说严格模式下的this指向\n\n- 在严格模式下，在全局作用域中，this指向window对象\n- 在严格模式下，函数中的this等于undefined\n- 在严格模式下，对象的函数中的this指向调用函数的对象实例\n- 在严格模式下，构造函数中的this指向构造函数创建的对象实例。\n- 在严格模式下，在事件处理函数中，this指向触发事件的目标对象。\n\n## 6. 图片懒加载原理\n   \n  图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的\n\n- 拿到所有的图片 dom 。\n- 遍历每个图片判断当前图片是否到了可视区范围内。\n- 如果到了就设置图片的 src 属性。\n- 绑定 window 的 scroll 事件，对其进行事件监听（搭配节流）。\n\n``` js\nlet imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\n// 修正错误，需要加上自执行\n- const imgLazyLoad = function() {\n+ const imgLazyLoad = (function() {\n    let count = 0\n    \n   return function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) =\u003e {\n            let rect = img.getBoundingClientRect()\n            if (rect.top \u003c window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) =\u003e !deleteIndexList.includes(index))\n   }\n- }\n+ })()\n\n// 这里最好加上节流处理\ndocument.addEventListener('scroll', imgLazyLoad)\n\n```\n\n## 7. 懒加载和预加载\n\n  两者都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n## 8. 如何区分返回内容是文件流还是json数据\n\n``` javascript\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n## 9. 写一个方法判断js的方法是内置的还是自定义的\n\ntoString一下\n``` javascript\nfunction isNative (f) {\n    return typeof f === 'function' \u0026\u0026 /native code/.test(f.toString())\n}\n```\n\n## 10. 微任务与宏任务\n\n- JavaScript是单线程的语言\n- Event Loop是javascript的执行机制\n\n![interview-js-event-loop](interview-js-event-loop.jpeg)\n\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n  js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数，也就是说‘同一层’既有微任务也有宏任务的时候，先执行微任务\n\n``` javascript\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n```\n\n## 11. 函数的方法 call()、apply()、bind()的区别\n\n### 改变函数执行上下文，也就是改变this的指向\n\n- call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。\n- call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n\n## 12. 前端性能优化\n- 减少 HTTP 请求\n- 使用 HTTP2\n- 使用服务端渲染\n  \n  客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\n  服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\n\n- 静态资源使用 CDN\n- 将 CSS 放在文件头部，JavaScript 文件放在底部\n- 使用字体图标 iconfont 代替图片图标\n- 善用缓存，不重复加载相同的资源\n- 压缩文件（js，css，图片）\n- 图片优化（懒加载，base64）\n- 分chunk，大的库考虑用CDN（react，router等）\n- 使用事件委托\n- if-else 对比 switch\n  \n  当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\n- 使用 Web Workers\n- 降低 CSS 选择器的复杂性（勿嵌套多层）\n\n## 13. 什么是防抖和节流，应用场景是啥\n    \n### 都是用于限制函数被频繁调用\n\n**防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**\n\n场景：有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n**节流：任务频繁触发的情况下，指定时间间隔内只会执行一次任务。**\n\n场景：懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取；双十一抢商品\n\n## 14. 实现链式调用\n    \n链式调用的核心就在于调用完的方法将自身实例返回\n\n``` javascript\nfunction Class1() {\n    console.log('初始化')\n}\nClass1.prototype.method = function(param) {\n    console.log(param)\n    return this\n}\nlet cl = new Class1()\n//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。\ncl.method('第一次调用').method('第二次链式调用').method('第三次链式调用')\n```\n    \n## 15. 继承\n    \n**原型链继承**\n\n``` javascript\nfunction Animal() {\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getColor = function() {\n    return this.colors\n}\nfunction Dog() {}\nDog.prototype =  new Animal()\n\nlet dog1 = new Dog()\ndog1.colors.push('brown')\nlet dog2 = new Dog()\nconsole.log(dog2.colors)  // ['black', 'white', 'brown']\n```\n\n**问题**\n\n- 原型中的属性会被共享\n- 实例化时无法给父类构造函数传参\n  \n**借用构造函数实现继承**\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.getName = function() {\n        return this.name\n    }\n}\nfunction Dog(name) {\n    Animal.call(this, name)\n}\n```\n借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以**会导致每次创建子类实例都会创建一遍方法**。\n\n**组合继承**\n\n组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n``` javascript\nfunction Animal(name) {\n    this.name = name\n    this.colors = ['black', 'white']\n}\nAnimal.prototype.getName = function() {\n    return this.name\n}\nfunction Dog(name, age) {\n    Animal.call(this, name)\n    this.age = age\n}\nDog.prototype =  new Animal()\nDog.prototype.constructor = Dog\n\nlet dog1 = new Dog('奶昔', 2)\ndog1.colors.push('brown')\nlet dog2 = new Dog('哈赤', 1)\nconsole.log(dog2) // { name: \"哈赤\", colors: [\"black\", \"white\"], age: 1 }\n```\n\n## 16. js中的堆栈\n    \n### 栈数据结构\n\n- 栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。\n- 栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。\n\n### 堆数据结构\n\n- 堆是一种经过排序的树形数据结构，每个结点都有一个值。\n- 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。\n\n### 变量类型与内存的关系\n\n#### 基本数据类型\n\nSting、Number、Boolean、null、undefined、Symbol\n\n- 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。\n- 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址\n\n\n## 17. Proxy的理解\n\n### 回答要点\n- Proxy的作用（拦截读取，写入等操作，可以覆盖原生操作）\n- Proxy和Object.defineProperty的区别（优势，Vue3用Proxy取代2版的defineProperty）\n- Reflect的用法（了解）\n\n### 链接\n[Proxy 和 Reflect](https://juejin.cn/post/6844904090116292616)\n\n## 18. Generator详解\n\n- 可控制的异步流程\n- async是Generator的实现（语法糖）\n\n## 19. 搞懂prototype和 __proto__\n\n### javascript继承的本质\n\n一个对象 A的__proto__属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链。\n\n### new 操作到底做了什么\n\n## 20. script标签中defer和async的区别\n\n都是异步加载 script 脚本\n- 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。\n- 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。\n\n## 21. CommonJs和Es Module的区别\n\n### CommonJs\n\n- CommonJs可以动态加载语句，代码发生在运行时\n- CommonJs导出值是拷贝，可以修改导出的值\n\n### Es Module\n\n- Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时\n- Es Module混合导出，单个导出，默认导出，完全互不影响\n- Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改\n\n### 题外话\n\nwebpack treeshaking 是基于静态检查，所以尽量使用 Es Module。\n\n\n\n\n"},"nextPost":null},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"html"},"buildId":"hvZYMQHlRPl8W4d97uc5m","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/main-c6f966696d7d46f48c33.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" async=""></script><script src="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" async=""></script><script src="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" async=""></script><script src="/_next/static/hvZYMQHlRPl8W4d97uc5m/_buildManifest.js" async=""></script><script src="/_next/static/hvZYMQHlRPl8W4d97uc5m/_ssgManifest.js" async=""></script></body></html>