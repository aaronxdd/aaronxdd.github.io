<!DOCTYPE html><html lang="en-US"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if("system"===e||(!e&&true)){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else if(e) d.add(e)}catch(e){}}()</script><title>面试题集合（框架篇） | Xu dongdong&#x27;s blog</title><meta name="description" content="A blog created with Next.js and Tailwind.css"/><meta property="og:type" content="website"/><meta name="og:title" property="og:title" content="面试题集合（框架篇）"/><meta name="og:description" property="og:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="面试题集合（框架篇）"/><meta name="twitter:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:creator" content="https://twitter.com/WhyYouJames"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/f8d73a71d7937abe53e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8d73a71d7937abe53e1.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c6f966696d7d46f48c33.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" as="script"/><link rel="preload" href="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" as="script"/></head><body><div id="__next"><div class="w-full min-h-screen dark:bg-gray-700 dark:text-white flex"><div class="max-w-screen-md px-4 py-12 mx-auto antialiased font-body flex flex-col flex-grow"><header class="flex items-center justify-between  mb-2"><div class="max-w-lg"><h1><a class="text-2xl font-black text-black no-underline font-display dark:text-white" href="/">Xu dongdong&#x27;s blog</a></h1></div></header><main class="flex-grow"><article><header class="mb-8"><h1 class="mb-2 text-6xl font-black leading-none font-display">面试题集合（框架篇）</h1></header><div class="mb-4 prose lg:prose-lg dark:prose-dark"><h2>1. 什么时候使用状态管理器（React）</h2><ul><li>state并不总是以单向的方式线性流动</li><li>存在组件需要更新全局状态</li><li>存在组件需要更新另一个组件的状态</li><li>某个状态需要在全局使用或共享（例如角色权限等信息）</li></ul><h2>2. redux-saga和redux-thunk有什么本质的区别</h2><p><strong>redux-thunk</strong> 中 <strong>dispatch</strong> 可以接受一个函数作为参数，而 <strong>redux-saga</strong> 其实和原始的 <strong>redux</strong> 保持一致，<strong>dispatch</strong> 的只是一个对象(plain object),异步是通过saga文件中的 <strong>generator</strong> 函数来处理的</p><h2>3. React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化</h2><ul><li>优化资源加载（减少http请求，采用CDN静态资源，小图片base64）</li><li>首屏考虑SSR</li><li>图片使用懒加载</li><li>相关资源的预加载</li><li>关于可视化的显示可以加入骨架</li><li>分chunk实现动态加载组件</li><li>Service worker做缓存</li><li>开发中遍历要给组件加key</li><li>css勿嵌套多层</li><li>不必要的dom标签用Fragments</li><li>考虑redux的必要性</li></ul><h2>4. react 最新版本解决了什么问题 加了哪些东西</h2><h2>5. React 事件绑定原理</h2><p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p><p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。</p><h2>6. webpack 做过哪些优化，开发效率方面、打包策略方面等等</h2><p><a href="https://github.com/lgwebdream/FE-Interview/issues/25">查看答案</a></p><h2>7. 说一下 react-fiber</h2><p><a href="https://github.com/lgwebdream/FE-Interview/issues/33">查看答案</a></p><h2>8. React 18的新特性</h2><ul><li>新的 <strong>ReactDOM.createRoot()</strong> API（替换 <strong>ReactDOM.render()</strong>）</li><li>新的 <strong>startTransition</strong> API（用于非紧急状态更新）</li><li>渲染的自动批处理优化（主要解决异步回调中无法批处理的问题）</li><li>支持 <strong>React.lazy</strong> 的 全新 SSR 架构（支持 <strong><suspense></suspense></strong> 组件）</li></ul><h2>9. React 开发Tips</h2><p>官方文档即是最佳实践</p><ol><li><p>尽量使用 react 高版本进行开发</p><ul><li>fiber 组件更新的优势</li><li>各种官方 hook 的使用（useMemo，useCallback）</li><li>等等</li></ul></li><li><p>数组遍历渲染时，key的正确使用</p></li><li><p>Fragment 的使用</p></li><li><p>Suspense 和 lazy 的搭配使用（懒加载）</p></li><li><p>代码的提取（HOC，手写hook）</p></li><li><p>合理使用状态管理（Redux，Context）</p></li></ol><h2>10. React的合成事件</h2><p>由于fiber机制的特点，生成一个fiber节点时，它对应的dom节点有可能还未挂载，onClick这样的事件处理函数作为fiber节点的prop，也就不能直接被绑定到真实的DOM节点上。
为此，React提供了一种“顶层注册，事件收集，统一触发”的事件机制。</p><p>委托到顶层root根节点上</p><h2>11. setState 是异步还是同步</h2><ul><li>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</li><li>setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</li><li>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</li></ul></div><hr class="mt-4"/><footer><div class="flex items-center mt-8 mb-16"><picture class="flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow"><source type="image/webp" data-srcset="/_next/static/images/profile-8ed88833980dc158e6d9ec3b1bb7c0a8.png.webp"/><source type="image/png" data-srcset="/_next/static/images/profile-44443f720aaa2ff4c2b67336ff9f586b.png"/><img class="lazyload blur flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow" alt="Profile" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAAFBSURBVAXBSS8DYQCA4fcz33RqWpUuU8tEkKjtUqIhJELiRCJxcfRf/AknP8OFiwMXF40DSVO0iRhLVbR0mX08jzg63Ikc28NzA1QR8vBcJ6Eq9AYUDMNAxlOsrBSRH40WIoLJbIL1qTzS63JvfRKJECd0MM0h9IREmZ4YOyaAw7UCG6UlNpfneaw8UbNa4Ie4tk9uSEO6nouCoO9FZEZNWu8WcUViZpLsH+wyMjnBX7eDzCuQ0zVsAtpvb1RrL9Stb3RNkO//MSwl6mAcWRrNMLO1jZ5UuSiXITXO6vISp+eXbNs+olal02kj/YUidiyJ5wsK63u8N74xSxmmyrecnF2TNtJoUkUa2RxO95ew3+al1yXm9tCCiLnCLPqrRbP5QSRC5GLsi0DVkekUj5UKjZ8+TSdA6ikWigYDqs/VzR3/TEV/Airrby8AAAAASUVORK5CYII="/></picture><p class="text-base leading-7 font-semibold">不正经的人机交互工程师</p></div></footer></article><nav class="flex flex-wrap justify-between mb-10"><a class="text-lg font-bold" href="/post/http">← <!-- -->面试题集合（网络篇）</a><a class="text-lg font-bold" href="/post/write">面试题集合（手撕代码篇）<!-- --> →</a></nav></main><footer class="text-lg font-light mt-3">© <!-- -->2021<!-- --> <!-- -->Built with<!-- --> <a href="https://nextjs.org/">Next.js</a>🔥, Deployed on<!-- --> <a href="https://pages.github.com/">GitHub Pages</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"面试题集合（框架篇）","date":"July 1, 2021","description":null},"post":{"content":"\n## 1. 什么时候使用状态管理器（React）\n\n   - state并不总是以单向的方式线性流动\n   - 存在组件需要更新全局状态\n   - 存在组件需要更新另一个组件的状态\n   - 某个状态需要在全局使用或共享（例如角色权限等信息）\n\n## 2. redux-saga和redux-thunk有什么本质的区别\n\n**redux-thunk** 中 **dispatch** 可以接受一个函数作为参数，而 **redux-saga** 其实和原始的 **redux** 保持一致，**dispatch** 的只是一个对象(plain object),异步是通过saga文件中的 **generator** 函数来处理的\n\n## 3. React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化\n   \n  - 优化资源加载（减少http请求，采用CDN静态资源，小图片base64）\n  - 首屏考虑SSR\n  - 图片使用懒加载\n  - 相关资源的预加载\n  - 关于可视化的显示可以加入骨架\n  - 分chunk实现动态加载组件\n  - Service worker做缓存\n  - 开发中遍历要给组件加key\n  - css勿嵌套多层\n  - 不必要的dom标签用Fragments\n  - 考虑redux的必要性\n  \n## 4. react 最新版本解决了什么问题 加了哪些东西\n## 5. React 事件绑定原理\n   \nReact并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n## 6. webpack 做过哪些优化，开发效率方面、打包策略方面等等\n   \n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/25)\n\n## 7. 说一下 react-fiber\n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/33)\n\n## 8. React 18的新特性\n\n  - 新的 **ReactDOM.createRoot()** API（替换 **ReactDOM.render()**）\n  - 新的 **startTransition** API（用于非紧急状态更新）\n  - 渲染的自动批处理优化（主要解决异步回调中无法批处理的问题）\n  - 支持 **React.lazy** 的 全新 SSR 架构（支持 **\u003cSuspense\u003e** 组件）\n\n## 9. React 开发Tips\n\n官方文档即是最佳实践\n\n1. 尽量使用 react 高版本进行开发\n     - fiber 组件更新的优势\n     - 各种官方 hook 的使用（useMemo，useCallback）\n     - 等等\n\n2. 数组遍历渲染时，key的正确使用\n3. Fragment 的使用\n4. Suspense 和 lazy 的搭配使用（懒加载）\n5. 代码的提取（HOC，手写hook）\n6. 合理使用状态管理（Redux，Context）\n\n## 10. React的合成事件\n\n由于fiber机制的特点，生成一个fiber节点时，它对应的dom节点有可能还未挂载，onClick这样的事件处理函数作为fiber节点的prop，也就不能直接被绑定到真实的DOM节点上。\n为此，React提供了一种“顶层注册，事件收集，统一触发”的事件机制。\n\n委托到顶层root根节点上\n\n## 11. setState 是异步还是同步\n\n- setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。\n- setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。\n- setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。\n","excerpt":""},"previousPost":{"slug":"http","frontmatter":{"title":"面试题集合（网络篇）","date":"July 1, 2021","description":null},"excerpt":"","content":"\n## 1. TCP/IP 四层网络模型\n\n第一层：应用层，主要有负责web浏览器的 **HTTP** 协议， 文件传输的 **FTP** 协议，负责电子邮件的 **SMTP** 协议，负责域名系统的 **DNS** 等。\n第二层：传输层，主要是有可靠传输的 **TCP** 协议，特别高效的 **UDP** 协议。主要负责传输应用层的数据包。\n第三层：网络层，主要是 **IP** 协议。主要负责寻址（找到目标设备的位置）\n第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。\n\n## 2. 用户输入url到页面展示的过程\n   \n- DNS解析\n  \n  域名到真实IP的寻址过程\n- 发起TCP连接\n  \n  三次握手🤝，确定 **client** ，**server** 双端的接受发送能力\n- 发起Http请求\n- 服务器处理请求并返回HTTP报文\n- 浏览器解析渲染页面\n\n## 3. 说一下 Http 缓存策略，有什么区别，分别解决了什么问题\n   \n   浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。\n\n  - 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\n  - 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified通过请求 发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\n\n  HTTP缓存都是从第二次请求开始的：\n\n  - 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\n  - 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：\n  ![chrome-cache](chrome-cache.jpeg)\n\n## 4. 常见的Http状态码\n\n- 200 OK：表示从客户端发送给服务器的请求被正常处理并返回\n- 204 No Content：表示客户端发送给服务端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）\n- 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL\n- 302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL\n- 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码\n- 400 Bad Request：表示请求报文中存在语法错误（一般指参数）\n- 401 Unauthorized：没有经过身份认证，需要通过HTTP认证\n- 403 Forbidden：身份认证过了，但是没有权限\n- 404 Not Found：(客户端问题)请求的资源没有找到，说明客户端错误的请求了不存在的资源\n- 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时\n- 503 Server Unavailable：服务不可用，一般指维护中或者服务重启中\n\n## 5. 跨域的复杂请求和简单请求的区别\n\n### 简单请求\n\n- HTTP方法是下列之一（HEAD、GET、POST）\n- HTTP头信息不超出以下几种字段\n  \n  **Accept**\n\n  **Accept-Language**\n\n  **Content-Type** （application/x-www-form-urlencoded、multipart/form-data、text/plain）\n\n任何一个 **不满足上述要求** 的请求，即被认为是复杂请求\n\n### 复杂请求\n\n- 一个复杂请求不仅有：包含通信内容的请求，同时也包含预请求。\n\n- 复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种\"预请求\"，此时作为服务端，也需要返回\"预回应\"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。\n\n## 5. TCP和UDP\n\n- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。\n- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为\n- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP\n- HTTP3.0取两者之长\n"},"nextPost":{"slug":"write","frontmatter":{"title":"面试题集合（手撕代码篇）","date":"July 5, 2021","description":null},"excerpt":"","content":"\n  \n## 1. 手写 bind、call、apply\n\n``` javascript\n// call\nFunction.prototype.myCall = (content) =\u003e {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  const result = content.fn(args);\n  delete content.fn;\n  return result;\n}\n\n// apply\nFunction.prototype.myApply = (content) =\u003e {\n  content = content || window;\n  content.fn = this;\n  let result\n  if (arguments[1] \u0026\u0026 Array.isArray(arguments[1])) {\n    if (arguments[1].length === 1) {\n      result = content.fn(...arguments[1])\n    } else {\n      result = content.fn()\n    }\n  }\n  delete content.fn\n  return result\n}\n\n// bind\nFunction.prototype.myBind = (content) =\u003e {\n  content = content || window;\n  content.fn = this;\n  const args = [...arguments].slice(1);\n  return () =\u003e {\n    content.fn(args)\n  }\n}\n```\n\n## 2. 手写防抖节流\n   \n   防抖\n   ``` javascript\n    const debounce = (fn, delay) =\u003e {\n      let timeout = null;\n      return () =\u003e {\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = setTimeout(() =\u003e {\n          fn.call(this, arguments)\n        }, delay)\n      }\n    }\n   ```\n   节流\n   ``` javascript\n    const throttle = (fn, delay) =\u003e {\n      let canRun = true;\n      if (!canRun) {\n        return\n      }\n      canRun = false;\n      setTimeout(() =\u003e {\n        fn.call(this. arguments);\n        canRun = true;\n      }, delay);\n    }\n   ```\n\n## 3. 手写数组flat\n\n``` javascript\nconst flat = arr =\u003e {\n  arr.reduce((pre, value) =\u003e {\n    return pre.concat(Array.isArray(value) ? flat(value) : value)\n  }, []);\n}\n```\n\n## 4. 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal\n\n``` javascript\nfunction mySetInterVal(fn, a, b) {\n  this.a = a;\n  this.b = b;\n  this.time = 0;\n  this.handle = -1;\n  this.start = () =\u003e {\n    this.handle = setTimeout(() =\u003e {\n      fn();\n      this.time++;\n      this.start();\n    }, this.a + this.time * this.b);\n  }\n\n  this.stop = () =\u003e {\n    clearTimeout(this.handle);\n    this.time = 0;\n  }\n}\n\nvar a = new mySetInterVal(() =\u003e {console.log('123')},1000, 2000 );\na.start();\na.stop();\n```\n\n## 5. 斐波那契数列\n   \n``` javascript\nconst Fibonacci = (n) =\u003e {\n  if (n \u003c 0) throw new Error('输入的数字不能小于0');\n  if (n \u003c 2) return n;\n  return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n```\n   \n## 7. 实现 add(1)(2)(3)\n   \n``` javascript\nconst add = (a) =\u003e (b) =\u003e (c) =\u003e a + b + c;\n```\n\n## 8. 数据类型判断\n\ntypeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。\n\n``` javascript\nconst getType = (obj) =\u003e {\n  return Object.prototype.toString.call(obj).slice(8, -1);\n}\n```\n\n## 9. 数组扁平化\n    \n数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层：\n\n``` javascript\n[1, [2, [3]]].flat(2)  // [1, 2, 3]\n```\n\n关键：递归\n\n``` javascript\nconst flatten = arr =\u003e {\n  let newArr = [];\n  for(let i = 0; i \u003c arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      newArr.concat(flatten(arr[i]))\n      return\n    }\n    newArr.push(arr[i])\n  }\n  return neaArr;\n}\n```\n\n## 10. 深浅拷贝\n\n浅拷贝：只考虑对象类型\n\nES5版\n``` javascript\nfunction shallowCopy(obj) {\n  if (typeof obj !== 'object') return\n\n  let newObj = obj instanceof Array ? [] : {};\n\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      newObj[i] = obj[i];\n    }\n  }\n\n  return newObj;\n}\n```\n\nES6版\n``` javascript\nconst shallowCopy = obj =\u003e Array.isArray(obj) ? [...obj] : {...obj}\n```\n\n深拷贝\n\n``` javascript\nconst deepClone = obj =\u003e {\n  if (typeof obj !== 'object') return;\n  let newObj = obj instanceof Array ? [] : {};\n  \n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (typeof obj[key] === 'object') {\n        newObj[key] = deepClone(obj[key]);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  return newObj;\n}\n```\n\n## 11. 解析 URL 参数为对象\n  \n``` javascript\nconst urlSearch = href =\u003e {\n  let obj = {};\n  const queryIndex = href.indexOf('?');\n  const urlOptions = href.slice(queryIndex + 1, href.length);\n  const options = urlOptions.split('\u0026');\n  options.map(option =\u003e {\n    const equalIndex = option.indexOf('=');\n    obj[option.slice(0, equalIndex)] = option.slice(equalIndex + 1, option.length);\n  });\n  return obj;\n}\n```\n\n## 12. 实现柯里化（Currying）\n\n``` javascript\nfunction curry(fn) {\n    let judge = (...args) =\u003e {\n        if (args.length == fn.length) return fn(...args)\n        return (...arg) =\u003e judge(...args, ...arg)\n    }\n    return judge\n}\n```\n\n## 13. 手写AJAX\n\n``` js\nconst myAjax = (url) =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onreadystatechange = () =\u003e {\n      if (xhr.readyState !== 4) return\n      if (xhr.status === 200) {\n        resolve(xhr.responseText)\n      } else {\n        reject(xhr.responseText)\n      }\n    }\n    xhr.send();\n  })\n}\n```\n\n## 14. 手写Promise\n\n``` javascript\nconst PADDING = \"PADDING\";\nconst FULFILLED = \"FULFILLED\";\nconst REJECTED = \"REJECTED\";\n\nclass MyPromise {\n  constructor(executor) {\n    this.status = PADDING;\n    this.value = undefined;\n    this.error = undefined;\n\n    let resolve = (value) =\u003e {\n      if (this.status === PADDING) {\n        this.value = value;\n        this.status = FULFILLED;\n      }\n    }\n\n    let reject = (error) =\u003e {\n      if (this.status === PADDING) {\n        this.error = error;\n        this.status = REJECTED;\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.error)\n    }\n  }\n}\n```\n    \n## 15. 实现 Promise.all\n  \n``` js\nconst promiseAll = (promises) =\u003e {\n  if (Array.isArray(promises)) {\n    throw new Error('the arguments must be an array !!!')\n  }\n  const promisesLength = promises.length;\n  let current = 0, result = [];\n  new Promise((resolve, reject) =\u003e {\n    promises.forEach((promise, i) =\u003e {\n      Promise.resolve(promise).then(value =\u003e {\n        current ++;\n        result[i] = value;\n        if (current === promisesLength) {\n          resolve(result)\n        }\n      }, error =\u003e reject(error))\n    })\n  })\n}\n```\n\n## 16. 手写模版字符串\n\n``` javascript\nconst render = (str, data) =\u003e {\n  const reg = /\\{\\{(\\w+)\\}\\}/;\n  if (reg.test(str)) {\n    const key = reg.exec(str)[1];\n    str = str.replace(reg, data[key]);\n    return render(str, data);\n  }\n  return str;\n} \n```"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"framework"},"buildId":"hvZYMQHlRPl8W4d97uc5m","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/main-c6f966696d7d46f48c33.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" async=""></script><script src="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" async=""></script><script src="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" async=""></script><script src="/_next/static/hvZYMQHlRPl8W4d97uc5m/_buildManifest.js" async=""></script><script src="/_next/static/hvZYMQHlRPl8W4d97uc5m/_ssgManifest.js" async=""></script></body></html>