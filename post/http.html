<!DOCTYPE html><html lang="en-US"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if("system"===e||(!e&&true)){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else if(e) d.add(e)}catch(e){}}()</script><title>面试题集合（网络篇） | Xu dongdong&#x27;s blog</title><meta name="description" content="A blog created with Next.js and Tailwind.css"/><meta property="og:type" content="website"/><meta name="og:title" property="og:title" content="面试题集合（网络篇）"/><meta name="og:description" property="og:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="面试题集合（网络篇）"/><meta name="twitter:description" content="A blog created with Next.js and Tailwind.css"/><meta name="twitter:creator" content="https://twitter.com/WhyYouJames"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/f8d73a71d7937abe53e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f8d73a71d7937abe53e1.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c6f966696d7d46f48c33.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" as="script"/><link rel="preload" href="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" as="script"/></head><body><div id="__next"><div class="w-full min-h-screen dark:bg-gray-700 dark:text-white flex"><div class="max-w-screen-md px-4 py-12 mx-auto antialiased font-body flex flex-col flex-grow"><header class="flex items-center justify-between  mb-2"><div class="max-w-lg"><h1><a class="text-2xl font-black text-black no-underline font-display dark:text-white" href="/">Xu dongdong&#x27;s blog</a></h1></div></header><main class="flex-grow"><article><header class="mb-8"><h1 class="mb-2 text-6xl font-black leading-none font-display">面试题集合（网络篇）</h1></header><div class="mb-4 prose lg:prose-lg dark:prose-dark"><h2>1. TCP/IP 四层网络模型</h2><p>第一层：应用层，主要有负责web浏览器的 <strong>HTTP</strong> 协议， 文件传输的 <strong>FTP</strong> 协议，负责电子邮件的 <strong>SMTP</strong> 协议，负责域名系统的 <strong>DNS</strong> 等。
第二层：传输层，主要是有可靠传输的 <strong>TCP</strong> 协议，特别高效的 <strong>UDP</strong> 协议。主要负责传输应用层的数据包。
第三层：网络层，主要是 <strong>IP</strong> 协议。主要负责寻址（找到目标设备的位置）
第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。</p><h2>2. 用户输入url到页面展示的过程</h2><ul><li><p>DNS解析</p><p>域名到真实IP的寻址过程</p></li><li><p>发起TCP连接</p><p>三次握手🤝，确定 <strong>client</strong> ，<strong>server</strong> 双端的接受发送能力</p></li><li><p>发起Http请求</p></li><li><p>服务器处理请求并返回HTTP报文</p></li><li><p>浏览器解析渲染页面</p></li></ul><h2>3. 说一下 Http 缓存策略，有什么区别，分别解决了什么问题</h2><p>浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。</p><ul><li>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</li><li>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified通过请求 发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li></ul><p>HTTP缓存都是从第二次请求开始的：</p><ul><li>第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；</li><li>第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：
<picture class="w-full"><source type="image/webp" data-srcset="/_next/static/images/chrome-cache-5136c05f248b55237b8a26acd5e691a0.jpeg.webp"/><source type="image/png" data-srcset="/_next/static/images/chrome-cache-c74770ba3e42a56870896bbc2bf9f421.jpeg"/><img class="lazyload blur w-full" alt="chrome-cache" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAYACgMBEQACEQEDEQH/xAGiAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgsQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+gEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoLEQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP7qdSlvLCa5NveTGRZRJ5k7Syllto5bhI3WKa2jdJHWOGRXjfFuXWMqc7wDro7F1RFN7dsVRQWaUlmIAG5j3J6n3oA//9k="/></picture></li></ul><h2>4. 常见的Http状态码</h2><ul><li>200 OK：表示从客户端发送给服务器的请求被正常处理并返回</li><li>204 No Content：表示客户端发送给服务端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）</li><li>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL</li><li>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL</li><li>304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码</li><li>400 Bad Request：表示请求报文中存在语法错误（一般指参数）</li><li>401 Unauthorized：没有经过身份认证，需要通过HTTP认证</li><li>403 Forbidden：身份认证过了，但是没有权限</li><li>404 Not Found：(客户端问题)请求的资源没有找到，说明客户端错误的请求了不存在的资源</li><li>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时</li><li>503 Server Unavailable：服务不可用，一般指维护中或者服务重启中</li></ul><h2>5. 跨域的复杂请求和简单请求的区别</h2><h3>简单请求</h3><ul><li><p>HTTP方法是下列之一（HEAD、GET、POST）</p></li><li><p>HTTP头信息不超出以下几种字段</p><p><strong>Accept</strong></p><p><strong>Accept-Language</strong></p><p><strong>Content-Type</strong> （application/x-www-form-urlencoded、multipart/form-data、text/plain）</p></li></ul><p>任何一个 <strong>不满足上述要求</strong> 的请求，即被认为是复杂请求</p><h3>复杂请求</h3><ul><li><p>一个复杂请求不仅有：包含通信内容的请求，同时也包含预请求。</p></li><li><p>复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种&quot;预请求&quot;，此时作为服务端，也需要返回&quot;预回应&quot;作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。</p></li></ul><h2>5. TCP和UDP</h2><ul><li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li><li>HTTP3.0取两者之长</li></ul></div><hr class="mt-4"/><footer><div class="flex items-center mt-8 mb-16"><picture class="flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow"><source type="image/webp" data-srcset="/_next/static/images/profile-8ed88833980dc158e6d9ec3b1bb7c0a8.png.webp"/><source type="image/png" data-srcset="/_next/static/images/profile-44443f720aaa2ff4c2b67336ff9f586b.png"/><img class="lazyload blur flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14 select-none cursor-pointer hvr-float-shadow" alt="Profile" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAAFBSURBVAXBSS8DYQCA4fcz33RqWpUuU8tEkKjtUqIhJELiRCJxcfRf/AknP8OFiwMXF40DSVO0iRhLVbR0mX08jzg63Ikc28NzA1QR8vBcJ6Eq9AYUDMNAxlOsrBSRH40WIoLJbIL1qTzS63JvfRKJECd0MM0h9IREmZ4YOyaAw7UCG6UlNpfneaw8UbNa4Ie4tk9uSEO6nouCoO9FZEZNWu8WcUViZpLsH+wyMjnBX7eDzCuQ0zVsAtpvb1RrL9Stb3RNkO//MSwl6mAcWRrNMLO1jZ5UuSiXITXO6vISp+eXbNs+olal02kj/YUidiyJ5wsK63u8N74xSxmmyrecnF2TNtJoUkUa2RxO95ew3+al1yXm9tCCiLnCLPqrRbP5QSRC5GLsi0DVkekUj5UKjZ8+TSdA6ikWigYDqs/VzR3/TEV/Airrby8AAAAASUVORK5CYII="/></picture><p class="text-base leading-7 font-semibold">不正经的人机交互工程师</p></div></footer></article><nav class="flex flex-wrap justify-between mb-10"><a class="text-lg font-bold" href="/post/data-structure">← <!-- -->数据结构笔记</a><a class="text-lg font-bold" href="/post/framework">面试题集合（框架篇）<!-- --> →</a></nav></main><footer class="text-lg font-light mt-3">© <!-- -->2021<!-- --> <!-- -->Built with<!-- --> <a href="https://nextjs.org/">Next.js</a>🔥, Deployed on<!-- --> <a href="https://pages.github.com/">GitHub Pages</a></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"面试题集合（网络篇）","date":"July 1, 2021","description":null},"post":{"content":"\n## 1. TCP/IP 四层网络模型\n\n第一层：应用层，主要有负责web浏览器的 **HTTP** 协议， 文件传输的 **FTP** 协议，负责电子邮件的 **SMTP** 协议，负责域名系统的 **DNS** 等。\n第二层：传输层，主要是有可靠传输的 **TCP** 协议，特别高效的 **UDP** 协议。主要负责传输应用层的数据包。\n第三层：网络层，主要是 **IP** 协议。主要负责寻址（找到目标设备的位置）\n第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。\n\n## 2. 用户输入url到页面展示的过程\n   \n- DNS解析\n  \n  域名到真实IP的寻址过程\n- 发起TCP连接\n  \n  三次握手🤝，确定 **client** ，**server** 双端的接受发送能力\n- 发起Http请求\n- 服务器处理请求并返回HTTP报文\n- 浏览器解析渲染页面\n\n## 3. 说一下 Http 缓存策略，有什么区别，分别解决了什么问题\n   \n   浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。\n\n  - 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\n  - 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified通过请求 发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\n\n  HTTP缓存都是从第二次请求开始的：\n\n  - 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\n  - 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：\n  ![chrome-cache](chrome-cache.jpeg)\n\n## 4. 常见的Http状态码\n\n- 200 OK：表示从客户端发送给服务器的请求被正常处理并返回\n- 204 No Content：表示客户端发送给服务端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）\n- 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL\n- 302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL\n- 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码\n- 400 Bad Request：表示请求报文中存在语法错误（一般指参数）\n- 401 Unauthorized：没有经过身份认证，需要通过HTTP认证\n- 403 Forbidden：身份认证过了，但是没有权限\n- 404 Not Found：(客户端问题)请求的资源没有找到，说明客户端错误的请求了不存在的资源\n- 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时\n- 503 Server Unavailable：服务不可用，一般指维护中或者服务重启中\n\n## 5. 跨域的复杂请求和简单请求的区别\n\n### 简单请求\n\n- HTTP方法是下列之一（HEAD、GET、POST）\n- HTTP头信息不超出以下几种字段\n  \n  **Accept**\n\n  **Accept-Language**\n\n  **Content-Type** （application/x-www-form-urlencoded、multipart/form-data、text/plain）\n\n任何一个 **不满足上述要求** 的请求，即被认为是复杂请求\n\n### 复杂请求\n\n- 一个复杂请求不仅有：包含通信内容的请求，同时也包含预请求。\n\n- 复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种\"预请求\"，此时作为服务端，也需要返回\"预回应\"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。\n\n## 5. TCP和UDP\n\n- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。\n- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为\n- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP\n- HTTP3.0取两者之长\n","excerpt":""},"previousPost":{"slug":"data-structure","frontmatter":{"title":"数据结构笔记","date":"June 30, 2021","description":null},"excerpt":"","content":"\n## 存储方式\n\n### 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）\n\n散列表、栈、队列、堆、树、图等等各种数据结构都属于上层建筑，而数组和链表才是「结构基础」。\n\n### 两者优缺点\n\n**数组**\n\n1. 由于是连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间，访问数组元素的时间复杂度 O(1)；\n2. 但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。\n\n**链表**\n\n1. 因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；\n2. 如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。\n3. 但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。\n\n\n## 基本操作\n\n数据结构的基本操作无非遍历 + 访问，即增删改查；\n\n但是不同数据结构的增删改查的效率是不一样的，所以我们需要了解各数据结构的特性以便我们在不同场景下提高代码的性能。\n\n遍历 + 访问 分为两种形式：线性的和非线性的。\n\n线性：以for/while 迭代为代表\n\n非线性：以递归为代表\n\n\n"},"nextPost":{"slug":"framework","frontmatter":{"title":"面试题集合（框架篇）","date":"July 1, 2021","description":null},"excerpt":"","content":"\n## 1. 什么时候使用状态管理器（React）\n\n   - state并不总是以单向的方式线性流动\n   - 存在组件需要更新全局状态\n   - 存在组件需要更新另一个组件的状态\n   - 某个状态需要在全局使用或共享（例如角色权限等信息）\n\n## 2. redux-saga和redux-thunk有什么本质的区别\n\n**redux-thunk** 中 **dispatch** 可以接受一个函数作为参数，而 **redux-saga** 其实和原始的 **redux** 保持一致，**dispatch** 的只是一个对象(plain object),异步是通过saga文件中的 **generator** 函数来处理的\n\n## 3. React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化\n   \n  - 优化资源加载（减少http请求，采用CDN静态资源，小图片base64）\n  - 首屏考虑SSR\n  - 图片使用懒加载\n  - 相关资源的预加载\n  - 关于可视化的显示可以加入骨架\n  - 分chunk实现动态加载组件\n  - Service worker做缓存\n  - 开发中遍历要给组件加key\n  - css勿嵌套多层\n  - 不必要的dom标签用Fragments\n  - 考虑redux的必要性\n  \n## 4. react 最新版本解决了什么问题 加了哪些东西\n## 5. React 事件绑定原理\n   \nReact并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n## 6. webpack 做过哪些优化，开发效率方面、打包策略方面等等\n   \n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/25)\n\n## 7. 说一下 react-fiber\n   [查看答案](https://github.com/lgwebdream/FE-Interview/issues/33)\n\n## 8. React 18的新特性\n\n  - 新的 **ReactDOM.createRoot()** API（替换 **ReactDOM.render()**）\n  - 新的 **startTransition** API（用于非紧急状态更新）\n  - 渲染的自动批处理优化（主要解决异步回调中无法批处理的问题）\n  - 支持 **React.lazy** 的 全新 SSR 架构（支持 **\u003cSuspense\u003e** 组件）\n\n## 9. React 开发Tips\n\n官方文档即是最佳实践\n\n1. 尽量使用 react 高版本进行开发\n     - fiber 组件更新的优势\n     - 各种官方 hook 的使用（useMemo，useCallback）\n     - 等等\n\n2. 数组遍历渲染时，key的正确使用\n3. Fragment 的使用\n4. Suspense 和 lazy 的搭配使用（懒加载）\n5. 代码的提取（HOC，手写hook）\n6. 合理使用状态管理（Redux，Context）"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"http"},"buildId":"lP5UBID9r0b6O5XyetSKd","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/main-c6f966696d7d46f48c33.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.10b3d8f36ae5d485c3da.js" async=""></script><script src="/_next/static/chunks/commons.18cd929bdef6e2f96561.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c6d80ab417193f95407.js" async=""></script><script src="/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.c3b64f225a2ce340a522.js" async=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-13092b6d8cea2defd1b4.js" async=""></script><script src="/_next/static/lP5UBID9r0b6O5XyetSKd/_buildManifest.js" async=""></script><script src="/_next/static/lP5UBID9r0b6O5XyetSKd/_ssgManifest.js" async=""></script></body></html>